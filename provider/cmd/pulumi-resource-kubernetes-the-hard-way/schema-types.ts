/* tslint:disable */
/**
 * This file was automatically generated by pulumi-provider-scripts.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source Pulumi Schema file,
 * and run "pulumi-provider-scripts gen-provider-types" to regenerate this file. */
import * as pulumi from "@pulumi/pulumi";
export type ConstructComponent<T extends pulumi.ComponentResource = pulumi.ComponentResource> = (name: string, inputs: any, options: pulumi.ComponentResourceOptions) => T;
export type ResourceConstructor = {
    readonly "kubernetes-the-hard-way:config:KubeVipManifest": ConstructComponent<KubeVipManifest>;
    readonly "kubernetes-the-hard-way:remote:CniBridgePluginConfiguration": ConstructComponent<CniBridgePluginConfiguration>;
    readonly "kubernetes-the-hard-way:remote:CniLoopbackPluginConfiguration": ConstructComponent<CniLoopbackPluginConfiguration>;
    readonly "kubernetes-the-hard-way:remote:CniPluginConfiguration": ConstructComponent<CniPluginConfiguration>;
    readonly "kubernetes-the-hard-way:remote:CniPluginsInstall": ConstructComponent<CniPluginsInstall>;
    readonly "kubernetes-the-hard-way:remote:ContainerdInstall": ConstructComponent<ContainerdInstall>;
    readonly "kubernetes-the-hard-way:remote:CrictlInstall": ConstructComponent<CrictlInstall>;
    readonly "kubernetes-the-hard-way:remote:Download": ConstructComponent<Download>;
    readonly "kubernetes-the-hard-way:remote:EtcdCluster": ConstructComponent<EtcdCluster>;
    readonly "kubernetes-the-hard-way:remote:EtcdConfiguration": ConstructComponent<EtcdConfiguration>;
    readonly "kubernetes-the-hard-way:remote:EtcdInstall": ConstructComponent<EtcdInstall>;
    readonly "kubernetes-the-hard-way:remote:EtcdService": ConstructComponent<EtcdService>;
    readonly "kubernetes-the-hard-way:remote:File": ConstructComponent<File>;
    readonly "kubernetes-the-hard-way:remote:KubeApiServerInstall": ConstructComponent<KubeApiServerInstall>;
    readonly "kubernetes-the-hard-way:remote:KubeControllerManagerInstall": ConstructComponent<KubeControllerManagerInstall>;
    readonly "kubernetes-the-hard-way:remote:KubeProxyInstall": ConstructComponent<KubeProxyInstall>;
    readonly "kubernetes-the-hard-way:remote:KubeSchedulerInstall": ConstructComponent<KubeSchedulerInstall>;
    readonly "kubernetes-the-hard-way:remote:KubectlInstall": ConstructComponent<KubectlInstall>;
    readonly "kubernetes-the-hard-way:remote:KubeletInstall": ConstructComponent<KubeletInstall>;
    readonly "kubernetes-the-hard-way:remote:ProvisionEtcd": ConstructComponent<ProvisionEtcd>;
    readonly "kubernetes-the-hard-way:remote:RuncInstall": ConstructComponent<RuncInstall>;
    readonly "kubernetes-the-hard-way:remote:StartEtcd": ConstructComponent<StartEtcd>;
    readonly "kubernetes-the-hard-way:remote:StaticPod": ConstructComponent<StaticPod>;
    readonly "kubernetes-the-hard-way:remote:SystemdService": ConstructComponent<SystemdService>;
    readonly "kubernetes-the-hard-way:tls:Certificate": ConstructComponent<Certificate>;
    readonly "kubernetes-the-hard-way:tls:ClusterPki": ConstructComponent<ClusterPki>;
    readonly "kubernetes-the-hard-way:tls:EncryptionKey": ConstructComponent<EncryptionKey>;
    readonly "kubernetes-the-hard-way:tls:RootCa": ConstructComponent<RootCa>;
    readonly "kubernetes-the-hard-way:tools:Chmod": ConstructComponent<Chmod>;
    readonly "kubernetes-the-hard-way:tools:Curl": ConstructComponent<Curl>;
    readonly "kubernetes-the-hard-way:tools:Etcdctl": ConstructComponent<Etcdctl>;
    readonly "kubernetes-the-hard-way:tools:Hostnamectl": ConstructComponent<Hostnamectl>;
    readonly "kubernetes-the-hard-way:tools:Mkdir": ConstructComponent<Mkdir>;
    readonly "kubernetes-the-hard-way:tools:Mktemp": ConstructComponent<Mktemp>;
    readonly "kubernetes-the-hard-way:tools:Mv": ConstructComponent<Mv>;
    readonly "kubernetes-the-hard-way:tools:Rm": ConstructComponent<Rm>;
    readonly "kubernetes-the-hard-way:tools:Sed": ConstructComponent<Sed>;
    readonly "kubernetes-the-hard-way:tools:Systemctl": ConstructComponent<Systemctl>;
    readonly "kubernetes-the-hard-way:tools:Tar": ConstructComponent<Tar>;
    readonly "kubernetes-the-hard-way:tools:Tee": ConstructComponent<Tee>;
    readonly "kubernetes-the-hard-way:tools:Wget": ConstructComponent<Wget>;
};
export type Functions = {
    "kubernetes-the-hard-way:config:getKubeVipManifest": (inputs: getKubeVipManifestInputs) => Promise<getKubeVipManifestOutputs>;
    "kubernetes-the-hard-way:config:getKubeconfig": (inputs: getKubeconfigInputs) => Promise<getKubeconfigOutputs>;
    "kubernetes-the-hard-way:tls:ClusterPki/getKubeconfig": (inputs: ClusterPki_getKubeconfigInputs) => Promise<ClusterPki_getKubeconfigOutputs>;
};
import * as command from "@pulumi/command";
import * as kubernetes from "@pulumi/kubernetes";
import * as random from "@pulumi/random";
import * as tls from "@pulumi/tls";
export abstract class KubeVipManifest<TData = any> extends (pulumi.ComponentResource)<TData> {
    public result!: PodManifestOutputs | pulumi.Output<PodManifestOutputs>;
    public yaml!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:config:KubeVipManifest", name, opts.urn ? { result: undefined, yaml: undefined } : { name, args, opts }, opts);
    }
}
export interface KubeVipManifestArgs {
    readonly address: pulumi.Input<string>;
    readonly bgpAs?: pulumi.Input<number>;
    readonly bgpEnable?: pulumi.Input<boolean>;
    readonly bgpPeerAddress?: pulumi.Input<string>;
    readonly bgpPeerAs?: pulumi.Input<number>;
    readonly bgpPeerPass?: pulumi.Input<string>;
    readonly bgpPeers?: pulumi.Input<string>;
    readonly bgpRouterId?: pulumi.Input<string>;
    readonly cpEnable?: pulumi.Input<boolean>;
    readonly cpNamespace?: pulumi.Input<string>;
    readonly image?: pulumi.Input<string>;
    readonly kubeconfigPath: pulumi.Input<string>;
    readonly name?: pulumi.Input<string>;
    readonly namespace?: pulumi.Input<string>;
    readonly port?: pulumi.Input<number>;
    readonly svcEnable?: pulumi.Input<boolean>;
    readonly version?: pulumi.Input<string>;
    readonly vipArp?: pulumi.Input<boolean>;
    readonly vipCidr: pulumi.Input<number>;
    readonly vipDdns?: pulumi.Input<boolean>;
    readonly vipInterface?: pulumi.Input<string>;
    readonly vipLeaderElection?: pulumi.Input<boolean>;
    readonly vipLeaseDuration?: pulumi.Input<number>;
    readonly vipRenewDeadline?: pulumi.Input<number>;
    readonly vipRetryPeriod?: pulumi.Input<number>;
}
export abstract class CniBridgePluginConfiguration<TData = any> extends (pulumi.ComponentResource)<TData> {
    public bridge!: string | pulumi.Output<string>;
    public cniVersion!: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public file?: File | pulumi.Output<File>;
    public ipMasq!: boolean | pulumi.Output<boolean>;
    public ipam!: CniBridgeIpamOutputs | pulumi.Output<CniBridgeIpamOutputs>;
    public isGateway!: boolean | pulumi.Output<boolean>;
    public name!: string | pulumi.Output<string>;
    public path!: string | pulumi.Output<string>;
    public subnet?: string | pulumi.Output<string>;
    public type!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:CniBridgePluginConfiguration", name, opts.urn ? { bridge: undefined, cniVersion: undefined, connection: undefined, file: undefined, ipMasq: undefined, ipam: undefined, isGateway: undefined, name: undefined, path: undefined, subnet: undefined, type: undefined } : { name, args, opts }, opts);
    }
}
export interface CniBridgePluginConfigurationArgs {
    readonly bridge?: pulumi.Input<string>;
    readonly cniVersion?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly ipMasq?: pulumi.Input<boolean>;
    readonly ipam?: pulumi.Input<CniBridgeIpamInputs>;
    readonly isGateway?: pulumi.Input<boolean>;
    readonly name?: pulumi.Input<string>;
    readonly path?: pulumi.Input<string>;
    readonly subnet?: pulumi.Input<string>;
    readonly type?: pulumi.Input<string>;
}
export abstract class CniLoopbackPluginConfiguration<TData = any> extends (pulumi.ComponentResource)<TData> {
    public cniVersion!: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public file?: File | pulumi.Output<File>;
    public name!: string | pulumi.Output<string>;
    public path!: string | pulumi.Output<string>;
    public type!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:CniLoopbackPluginConfiguration", name, opts.urn ? { cniVersion: undefined, connection: undefined, file: undefined, name: undefined, path: undefined, type: undefined } : { name, args, opts }, opts);
    }
}
export interface CniLoopbackPluginConfigurationArgs {
    readonly cniVersion?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly name?: pulumi.Input<string>;
    readonly path?: pulumi.Input<string>;
    readonly type?: pulumi.Input<string>;
}
export abstract class CniPluginConfiguration<TData = any> extends (pulumi.ComponentResource)<TData> {
    public bridge!: CniBridgePluginConfiguration | pulumi.Output<CniBridgePluginConfiguration>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public directory!: string | pulumi.Output<string>;
    public loopback!: CniLoopbackPluginConfiguration | pulumi.Output<CniLoopbackPluginConfiguration>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public subnet!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:CniPluginConfiguration", name, opts.urn ? { bridge: undefined, connection: undefined, directory: undefined, loopback: undefined, mkdir: undefined, subnet: undefined } : { name, args, opts }, opts);
    }
}
export interface CniPluginConfigurationArgs {
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly subnet: pulumi.Input<string>;
}
export abstract class CniPluginsInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public archiveName!: string | pulumi.Output<string>;
    public bandwidthMv!: Mv | pulumi.Output<Mv>;
    public bandwidthPath!: string | pulumi.Output<string>;
    public bridgeMv!: Mv | pulumi.Output<Mv>;
    public bridgePath!: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public dhcpMv!: Mv | pulumi.Output<Mv>;
    public dhcpPath!: string | pulumi.Output<string>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public dummyMv!: Mv | pulumi.Output<Mv>;
    public dummyPath!: string | pulumi.Output<string>;
    public firewallMv!: Mv | pulumi.Output<Mv>;
    public firewallPath!: string | pulumi.Output<string>;
    public hostDeviceMv!: Mv | pulumi.Output<Mv>;
    public hostDevicePath!: string | pulumi.Output<string>;
    public hostLocalMv!: Mv | pulumi.Output<Mv>;
    public hostLocalPath!: string | pulumi.Output<string>;
    public ipvlanMv!: Mv | pulumi.Output<Mv>;
    public ipvlanPath!: string | pulumi.Output<string>;
    public loopbackMv!: Mv | pulumi.Output<Mv>;
    public loopbackPath!: string | pulumi.Output<string>;
    public macvlanMv!: Mv | pulumi.Output<Mv>;
    public macvlanPath!: string | pulumi.Output<string>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public path?: string | pulumi.Output<string>;
    public portmapMv!: Mv | pulumi.Output<Mv>;
    public portmapPath!: string | pulumi.Output<string>;
    public ptpMv!: Mv | pulumi.Output<Mv>;
    public ptpPath!: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public sbrMv!: Mv | pulumi.Output<Mv>;
    public sbrPath!: string | pulumi.Output<string>;
    public staticMv!: Mv | pulumi.Output<Mv>;
    public staticPath!: string | pulumi.Output<string>;
    public tapMv!: Mv | pulumi.Output<Mv>;
    public tapPath!: string | pulumi.Output<string>;
    public tar!: Tar | pulumi.Output<Tar>;
    public tuningMv!: Mv | pulumi.Output<Mv>;
    public tuningPath!: string | pulumi.Output<string>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    public vlanMv!: Mv | pulumi.Output<Mv>;
    public vlanPath!: string | pulumi.Output<string>;
    public vrfMv!: Mv | pulumi.Output<Mv>;
    public vrfPath!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:CniPluginsInstall", name, opts.urn ? { architecture: undefined, archiveName: undefined, bandwidthMv: undefined, bandwidthPath: undefined, bridgeMv: undefined, bridgePath: undefined, connection: undefined, dhcpMv: undefined, dhcpPath: undefined, directory: undefined, download: undefined, dummyMv: undefined, dummyPath: undefined, firewallMv: undefined, firewallPath: undefined, hostDeviceMv: undefined, hostDevicePath: undefined, hostLocalMv: undefined, hostLocalPath: undefined, ipvlanMv: undefined, ipvlanPath: undefined, loopbackMv: undefined, loopbackPath: undefined, macvlanMv: undefined, macvlanPath: undefined, mkdir: undefined, mktemp: undefined, path: undefined, portmapMv: undefined, portmapPath: undefined, ptpMv: undefined, ptpPath: undefined, rm: undefined, sbrMv: undefined, sbrPath: undefined, staticMv: undefined, staticPath: undefined, tapMv: undefined, tapPath: undefined, tar: undefined, tuningMv: undefined, tuningPath: undefined, url: undefined, version: undefined, vlanMv: undefined, vlanPath: undefined, vrfMv: undefined, vrfPath: undefined } : { name, args, opts }, opts);
    }
}
export interface CniPluginsInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class ContainerdInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public archiveName!: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public containerdMv!: Mv | pulumi.Output<Mv>;
    public containerdPath!: string | pulumi.Output<string>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public path?: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public tar!: Tar | pulumi.Output<Tar>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:ContainerdInstall", name, opts.urn ? { architecture: undefined, archiveName: undefined, connection: undefined, containerdMv: undefined, containerdPath: undefined, directory: undefined, download: undefined, mkdir: undefined, mktemp: undefined, path: undefined, rm: undefined, tar: undefined, url: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface ContainerdInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class CrictlInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public archiveName!: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public crictlMv!: Mv | pulumi.Output<Mv>;
    public crictlPath!: string | pulumi.Output<string>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public path?: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public tar!: Tar | pulumi.Output<Tar>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:CrictlInstall", name, opts.urn ? { architecture: undefined, archiveName: undefined, connection: undefined, crictlMv: undefined, crictlPath: undefined, directory: undefined, download: undefined, mkdir: undefined, mktemp: undefined, path: undefined, rm: undefined, tar: undefined, url: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface CrictlInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class Download<TData = any> extends (pulumi.ComponentResource)<TData> {
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public destination!: string | pulumi.Output<string>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public removeOnDelete!: boolean;
    public url!: string | pulumi.Output<string>;
    public wget!: Wget | pulumi.Output<Wget>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:Download", name, opts.urn ? { connection: undefined, destination: undefined, mkdir: undefined, removeOnDelete: undefined, url: undefined, wget: undefined } : { name, args, opts }, opts);
    }
}
export interface DownloadArgs {
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly destination: pulumi.Input<string>;
    readonly removeOnDelete?: boolean;
    readonly url: pulumi.Input<string>;
}
export abstract class EtcdCluster<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture?: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public binaryDirectory?: string | pulumi.Output<string>;
    public bundle!: BundleOutputs | pulumi.Output<BundleOutputs>;
    public configuration!: Record<string, EtcdConfiguration> | pulumi.Output<Record<string, EtcdConfiguration>>;
    public configurationDirectory?: string | pulumi.Output<string>;
    public dataDirectory?: string | pulumi.Output<string>;
    public install!: Record<string, EtcdInstall> | pulumi.Output<Record<string, EtcdInstall>>;
    public nodes!: Record<string, EtcdNodeOutputs>;
    public service!: Record<string, EtcdService> | pulumi.Output<Record<string, EtcdService>>;
    public start!: Record<string, StartEtcd> | pulumi.Output<Record<string, StartEtcd>>;
    public version?: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:EtcdCluster", name, opts.urn ? { architecture: undefined, binaryDirectory: undefined, bundle: undefined, configuration: undefined, configurationDirectory: undefined, dataDirectory: undefined, install: undefined, nodes: undefined, service: undefined, start: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface EtcdClusterArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly binaryDirectory?: pulumi.Input<string>;
    readonly bundle: pulumi.Input<BundleInputs>;
    readonly configurationDirectory?: pulumi.Input<string>;
    readonly dataDirectory?: pulumi.Input<string>;
    readonly nodes: Record<string, EtcdNodeInputs>;
    readonly version?: pulumi.Input<string>;
}
export abstract class EtcdConfiguration<TData = any> extends (pulumi.ComponentResource)<TData> {
    public caFile!: File | pulumi.Output<File>;
    public caPem!: string | pulumi.Output<string>;
    public certFile!: File | pulumi.Output<File>;
    public certPem!: string | pulumi.Output<string>;
    public configurationChmod?: Chmod | pulumi.Output<Chmod>;
    public configurationDirectory!: string | pulumi.Output<string>;
    public configurationMkdir!: Mkdir | pulumi.Output<Mkdir>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public dataDirectory!: string | pulumi.Output<string>;
    public dataMkdir!: Mkdir | pulumi.Output<Mkdir>;
    public etcdPath!: string | pulumi.Output<string>;
    public internalIp!: string | pulumi.Output<string>;
    public keyFile!: File | pulumi.Output<File>;
    public keyPem!: string | pulumi.Output<string>;
    public value!: EtcdConfigurationPropsOutputs | pulumi.Output<EtcdConfigurationPropsOutputs>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:EtcdConfiguration", name, opts.urn ? { caFile: undefined, caPem: undefined, certFile: undefined, certPem: undefined, configurationChmod: undefined, configurationDirectory: undefined, configurationMkdir: undefined, connection: undefined, dataDirectory: undefined, dataMkdir: undefined, etcdPath: undefined, internalIp: undefined, keyFile: undefined, keyPem: undefined, value: undefined } : { name, args, opts }, opts);
    }
}
export interface EtcdConfigurationArgs {
    readonly caPem: pulumi.Input<string>;
    readonly certPem: pulumi.Input<string>;
    readonly configurationDirectory?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly dataDirectory?: pulumi.Input<string>;
    readonly etcdPath: pulumi.Input<string>;
    readonly internalIp: pulumi.Input<string>;
    readonly keyPem: pulumi.Input<string>;
}
export abstract class EtcdInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public archiveName!: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public etcdMv!: Mv | pulumi.Output<Mv>;
    public etcdPath!: string | pulumi.Output<string>;
    public etcdctlMv!: Mv | pulumi.Output<Mv>;
    public etcdctlPath!: string | pulumi.Output<string>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public path?: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public tar!: Tar | pulumi.Output<Tar>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:EtcdInstall", name, opts.urn ? { architecture: undefined, archiveName: undefined, connection: undefined, directory: undefined, download: undefined, etcdMv: undefined, etcdPath: undefined, etcdctlMv: undefined, etcdctlPath: undefined, mkdir: undefined, mktemp: undefined, path: undefined, rm: undefined, tar: undefined, url: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface EtcdInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class EtcdService<TData = any> extends (pulumi.ComponentResource)<TData> {
    public configuration!: EtcdConfigurationPropsOutputs | pulumi.Output<EtcdConfigurationPropsOutputs>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public description?: string | pulumi.Output<string>;
    public directory?: string | pulumi.Output<string>;
    public documentation?: string | pulumi.Output<string>;
    public peers!: EtcdConfigurationPropsOutputs[] | pulumi.Output<EtcdConfigurationPropsOutputs[]>;
    public restart?: SystemdServiceRestartOutputs | pulumi.Output<SystemdServiceRestartOutputs>;
    public restartSec?: string | pulumi.Output<string>;
    public service!: SystemdService | pulumi.Output<SystemdService>;
    public wantedBy?: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:EtcdService", name, opts.urn ? { configuration: undefined, connection: undefined, description: undefined, directory: undefined, documentation: undefined, peers: undefined, restart: undefined, restartSec: undefined, service: undefined, wantedBy: undefined } : { name, args, opts }, opts);
    }
}
export interface EtcdServiceArgs {
    readonly configuration: pulumi.Input<EtcdConfigurationPropsInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly description?: pulumi.Input<string>;
    readonly directory?: pulumi.Input<string>;
    readonly documentation?: pulumi.Input<string>;
    readonly peers?: pulumi.Input<pulumi.Input<EtcdConfigurationPropsInputs>[]>;
    readonly restart?: pulumi.Input<SystemdServiceRestartInputs>;
    readonly restartSec?: pulumi.Input<string>;
    readonly wantedBy?: pulumi.Input<string>;
}
export abstract class File<TData = any> extends (pulumi.ComponentResource)<TData> {
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public content!: string | pulumi.Output<string>;
    public path!: string | pulumi.Output<string>;
    public stderr!: string | pulumi.Output<string>;
    public stdin!: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:File", name, opts.urn ? { command: undefined, connection: undefined, content: undefined, path: undefined, stderr: undefined, stdin: undefined, stdout: undefined } : { name, args, opts }, opts);
    }
}
export interface FileArgs {
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly content: pulumi.Input<string>;
    readonly path: pulumi.Input<string>;
}
export abstract class KubeApiServerInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public binName?: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public mv!: Mv | pulumi.Output<Mv>;
    public path!: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:KubeApiServerInstall", name, opts.urn ? { architecture: undefined, binName: undefined, connection: undefined, directory: undefined, download: undefined, mkdir: undefined, mktemp: undefined, mv: undefined, path: undefined, rm: undefined, url: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface KubeApiServerInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class KubeControllerManagerInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public binName?: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public mv!: Mv | pulumi.Output<Mv>;
    public path!: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:KubeControllerManagerInstall", name, opts.urn ? { architecture: undefined, binName: undefined, connection: undefined, directory: undefined, download: undefined, mkdir: undefined, mktemp: undefined, mv: undefined, path: undefined, rm: undefined, url: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface KubeControllerManagerInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class KubeProxyInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public binName?: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public mv!: Mv | pulumi.Output<Mv>;
    public path!: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:KubeProxyInstall", name, opts.urn ? { architecture: undefined, binName: undefined, connection: undefined, directory: undefined, download: undefined, mkdir: undefined, mktemp: undefined, mv: undefined, path: undefined, rm: undefined, url: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface KubeProxyInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class KubeSchedulerInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public binName?: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public mv!: Mv | pulumi.Output<Mv>;
    public path!: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:KubeSchedulerInstall", name, opts.urn ? { architecture: undefined, binName: undefined, connection: undefined, directory: undefined, download: undefined, mkdir: undefined, mktemp: undefined, mv: undefined, path: undefined, rm: undefined, url: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface KubeSchedulerInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class KubectlInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public binName?: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public mv!: Mv | pulumi.Output<Mv>;
    public path!: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:KubectlInstall", name, opts.urn ? { architecture: undefined, binName: undefined, connection: undefined, directory: undefined, download: undefined, mkdir: undefined, mktemp: undefined, mv: undefined, path: undefined, rm: undefined, url: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface KubectlInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class KubeletInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public binName?: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public mv!: Mv | pulumi.Output<Mv>;
    public path!: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:KubeletInstall", name, opts.urn ? { architecture: undefined, binName: undefined, connection: undefined, directory: undefined, download: undefined, mkdir: undefined, mktemp: undefined, mv: undefined, path: undefined, rm: undefined, url: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface KubeletInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class ProvisionEtcd<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture?: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public binaryDirectory?: string | pulumi.Output<string>;
    public bundle!: BundleOutputs | pulumi.Output<BundleOutputs>;
    public configuration!: EtcdConfiguration | pulumi.Output<EtcdConfiguration>;
    public configurationDirectory?: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public dataDirectory?: string | pulumi.Output<string>;
    public install!: EtcdInstall | pulumi.Output<EtcdInstall>;
    public internalIp!: string | pulumi.Output<string>;
    public service!: SystemdService | pulumi.Output<SystemdService>;
    public start!: StartEtcd | pulumi.Output<StartEtcd>;
    public version?: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:ProvisionEtcd", name, opts.urn ? { architecture: undefined, binaryDirectory: undefined, bundle: undefined, configuration: undefined, configurationDirectory: undefined, connection: undefined, dataDirectory: undefined, install: undefined, internalIp: undefined, service: undefined, start: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface ProvisionEtcdArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly binaryDirectory?: pulumi.Input<string>;
    readonly bundle: pulumi.Input<BundleInputs>;
    readonly configurationDirectory?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly dataDirectory?: pulumi.Input<string>;
    readonly internalIp: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class RuncInstall<TData = any> extends (pulumi.ComponentResource)<TData> {
    public architecture!: ArchitectureOutputs | pulumi.Output<ArchitectureOutputs>;
    public binName?: string | pulumi.Output<string>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public directory!: string | pulumi.Output<string>;
    public download!: Download | pulumi.Output<Download>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public mktemp!: Mktemp | pulumi.Output<Mktemp>;
    public mv!: Mv | pulumi.Output<Mv>;
    public path!: string | pulumi.Output<string>;
    public rm!: Rm | pulumi.Output<Rm>;
    public url!: string | pulumi.Output<string>;
    public version!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:RuncInstall", name, opts.urn ? { architecture: undefined, binName: undefined, connection: undefined, directory: undefined, download: undefined, mkdir: undefined, mktemp: undefined, mv: undefined, path: undefined, rm: undefined, url: undefined, version: undefined } : { name, args, opts }, opts);
    }
}
export interface RuncInstallArgs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly version?: pulumi.Input<string>;
}
export abstract class StartEtcd<TData = any> extends (pulumi.ComponentResource)<TData> {
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public daemonReload!: Systemctl | pulumi.Output<Systemctl>;
    public enable!: Systemctl | pulumi.Output<Systemctl>;
    public start!: Systemctl | pulumi.Output<Systemctl>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:StartEtcd", name, opts.urn ? { connection: undefined, daemonReload: undefined, enable: undefined, start: undefined } : { name, args, opts }, opts);
    }
}
export interface StartEtcdArgs {
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
}
export abstract class StaticPod<TData = any> extends (pulumi.ComponentResource)<TData> {
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public file!: File | pulumi.Output<File>;
    public fileName!: string | pulumi.Output<string>;
    public mkdir!: Mkdir | pulumi.Output<Mkdir>;
    public path!: string | pulumi.Output<string>;
    public pod!: PodManifestOutputs | pulumi.Output<PodManifestOutputs>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:StaticPod", name, opts.urn ? { connection: undefined, file: undefined, fileName: undefined, mkdir: undefined, path: undefined, pod: undefined } : { name, args, opts }, opts);
    }
}
export interface StaticPodArgs {
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly fileName?: pulumi.Input<string>;
    readonly pod: pulumi.Input<PodManifestInputs>;
}
export abstract class SystemdService<TData = any> extends (pulumi.ComponentResource)<TData> {
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public directory!: string | pulumi.Output<string>;
    public file!: File | pulumi.Output<File>;
    public install?: SystemdInstallSectionOutputs | pulumi.Output<SystemdInstallSectionOutputs>;
    public service!: SystemdServiceSectionOutputs | pulumi.Output<SystemdServiceSectionOutputs>;
    public unit?: SystemdUnitSectionOutputs | pulumi.Output<SystemdUnitSectionOutputs>;
    public unitName?: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:remote:SystemdService", name, opts.urn ? { connection: undefined, directory: undefined, file: undefined, install: undefined, service: undefined, unit: undefined, unitName: undefined } : { name, args, opts }, opts);
    }
}
export interface SystemdServiceArgs {
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly directory?: pulumi.Input<string>;
    readonly install?: pulumi.Input<SystemdInstallSectionInputs>;
    readonly service: pulumi.Input<SystemdServiceSectionInputs>;
    readonly unit?: pulumi.Input<SystemdUnitSectionInputs>;
    readonly unitName?: pulumi.Input<string>;
}
export abstract class Certificate<TData = any> extends (pulumi.ComponentResource)<TData> {
    public algorithm!: AlgorithmOutputs | pulumi.Output<AlgorithmOutputs>;
    public allowedUses!: AllowedUsageOutputs[] | pulumi.Output<AllowedUsageOutputs[]>;
    public caCertPem!: string | pulumi.Output<string>;
    public caKeyAlgorithm!: string | pulumi.Output<string>;
    public caPrivateKeyPem!: string | pulumi.Output<string>;
    public cert!: tls.LocallySignedCert | pulumi.Output<tls.LocallySignedCert>;
    public certPem!: string | pulumi.Output<string>;
    public certRequestPem!: string | pulumi.Output<string>;
    public csr!: tls.CertRequest | pulumi.Output<tls.CertRequest>;
    public dnsNames?: string[] | pulumi.Output<string[]>;
    public earlyRenewalHours!: number | pulumi.Output<number>;
    public ecdsaCurve!: EcdsaCurveOutputs | pulumi.Output<EcdsaCurveOutputs>;
    public ipAddresses?: string[] | pulumi.Output<string[]>;
    public isCaCertificate!: boolean | pulumi.Output<boolean>;
    public key!: tls.PrivateKey | pulumi.Output<tls.PrivateKey>;
    public keyAlgorithm!: string | pulumi.Output<string>;
    public privateKeyOpenssh!: string | pulumi.Output<string>;
    public privateKeyPem!: string | pulumi.Output<string>;
    public privateKeyPemPkcs8!: string | pulumi.Output<string>;
    public publicKeyFingerprintMd5!: string | pulumi.Output<string>;
    public publicKeyFingerprintSha256!: string | pulumi.Output<string>;
    public publicKeyOpenssh!: string | pulumi.Output<string>;
    public publicKeyPem!: string | pulumi.Output<string>;
    public readyForRenewal!: boolean | pulumi.Output<boolean>;
    public rsaBits!: number | pulumi.Output<number>;
    public setSubjectKeyId!: boolean | pulumi.Output<boolean>;
    public subject?: tls.types.output.CertRequestSubject | pulumi.Output<tls.types.output.CertRequestSubject>;
    public uris?: string[] | pulumi.Output<string[]>;
    public validityEndTime!: string | pulumi.Output<string>;
    public validityPeriodHours!: number | pulumi.Output<number>;
    public validityStartTime!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tls:Certificate", name, opts.urn ? { algorithm: undefined, allowedUses: undefined, caCertPem: undefined, caKeyAlgorithm: undefined, caPrivateKeyPem: undefined, cert: undefined, certPem: undefined, certRequestPem: undefined, csr: undefined, dnsNames: undefined, earlyRenewalHours: undefined, ecdsaCurve: undefined, ipAddresses: undefined, isCaCertificate: undefined, key: undefined, keyAlgorithm: undefined, privateKeyOpenssh: undefined, privateKeyPem: undefined, privateKeyPemPkcs8: undefined, publicKeyFingerprintMd5: undefined, publicKeyFingerprintSha256: undefined, publicKeyOpenssh: undefined, publicKeyPem: undefined, readyForRenewal: undefined, rsaBits: undefined, setSubjectKeyId: undefined, subject: undefined, uris: undefined, validityEndTime: undefined, validityPeriodHours: undefined, validityStartTime: undefined } : { name, args, opts }, opts);
    }
}
export interface CertificateArgs {
    readonly algorithm: pulumi.Input<AlgorithmInputs>;
    readonly allowedUses: pulumi.Input<pulumi.Input<AllowedUsageInputs>[]>;
    readonly caCertPem: pulumi.Input<string>;
    readonly caPrivateKeyPem: pulumi.Input<string>;
    readonly dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
    readonly earlyRenewalHours?: pulumi.Input<number>;
    readonly ecdsaCurve?: pulumi.Input<EcdsaCurveInputs>;
    readonly ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    readonly isCaCertificate?: pulumi.Input<boolean>;
    readonly rsaBits?: pulumi.Input<number>;
    readonly setSubjectKeyId?: pulumi.Input<boolean>;
    readonly subject?: pulumi.Input<tls.types.input.CertRequestSubject>;
    readonly uris?: pulumi.Input<pulumi.Input<string>[]>;
    readonly validityPeriodHours: pulumi.Input<number>;
}
export abstract class ClusterPki<TData = any> extends (pulumi.ComponentResource)<TData> {
    public admin!: Certificate | pulumi.Output<Certificate>;
    public algorithm?: AlgorithmOutputs | pulumi.Output<AlgorithmOutputs>;
    public ca!: RootCa | pulumi.Output<RootCa>;
    public clusterName!: string | pulumi.Output<string>;
    public controllerManager!: Certificate | pulumi.Output<Certificate>;
    public ecdsaCurve?: EcdsaCurveOutputs | pulumi.Output<EcdsaCurveOutputs>;
    public kubeProxy!: Certificate | pulumi.Output<Certificate>;
    public kubeScheduler!: Certificate | pulumi.Output<Certificate>;
    public kubelet!: Record<string, Certificate> | pulumi.Output<Record<string, Certificate>>;
    public kubernetes!: Certificate | pulumi.Output<Certificate>;
    public nodes!: Record<string, ClusterPkiNodeOutputs> | pulumi.Output<Record<string, ClusterPkiNodeOutputs>>;
    public publicIp!: string | pulumi.Output<string>;
    public rsaBits?: number | pulumi.Output<number>;
    public serviceAccounts!: Certificate | pulumi.Output<Certificate>;
    public validityPeriodHours!: number | pulumi.Output<number>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tls:ClusterPki", name, opts.urn ? { admin: undefined, algorithm: undefined, ca: undefined, clusterName: undefined, controllerManager: undefined, ecdsaCurve: undefined, kubeProxy: undefined, kubeScheduler: undefined, kubelet: undefined, kubernetes: undefined, nodes: undefined, publicIp: undefined, rsaBits: undefined, serviceAccounts: undefined, validityPeriodHours: undefined } : { name, args, opts }, opts);
    }
}
export interface ClusterPkiArgs {
    readonly algorithm?: pulumi.Input<AlgorithmInputs>;
    readonly clusterName: pulumi.Input<string>;
    readonly ecdsaCurve?: pulumi.Input<EcdsaCurveInputs>;
    readonly nodes: pulumi.Input<Record<string, pulumi.Input<ClusterPkiNodeInputs>>>;
    readonly publicIp: pulumi.Input<string>;
    readonly rsaBits?: pulumi.Input<number>;
    readonly validityPeriodHours?: pulumi.Input<number>;
}
export abstract class EncryptionKey<TData = any> extends (pulumi.ComponentResource)<TData> {
    public bytes!: number | pulumi.Output<number>;
    public config!: string | pulumi.Output<string>;
    public key!: random.RandomBytes | pulumi.Output<random.RandomBytes>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tls:EncryptionKey", name, opts.urn ? { bytes: undefined, config: undefined, key: undefined } : { name, args, opts }, opts);
    }
}
export interface EncryptionKeyArgs {
    readonly bytes: pulumi.Input<number>;
}
export abstract class RootCa<TData = any> extends (pulumi.ComponentResource)<TData> {
    public algorithm!: AlgorithmOutputs | pulumi.Output<AlgorithmOutputs>;
    public allowedUses!: string[] | pulumi.Output<string[]>;
    public cert!: tls.SelfSignedCert | pulumi.Output<tls.SelfSignedCert>;
    public certPem!: string | pulumi.Output<string>;
    public dnsNames?: string[] | pulumi.Output<string[]>;
    public earlyRenewalHours!: number | pulumi.Output<number>;
    public ecdsaCurve!: EcdsaCurveOutputs | pulumi.Output<EcdsaCurveOutputs>;
    public ipAddresses?: string[] | pulumi.Output<string[]>;
    public isCaCertificate!: boolean | pulumi.Output<boolean>;
    public key!: tls.PrivateKey | pulumi.Output<tls.PrivateKey>;
    public keyAlgorithm!: string | pulumi.Output<string>;
    public privateKeyOpenssh!: string | pulumi.Output<string>;
    public privateKeyPem!: string | pulumi.Output<string>;
    public privateKeyPemPkcs8!: string | pulumi.Output<string>;
    public publicKeyFingerprintMd5!: string | pulumi.Output<string>;
    public publicKeyFingerprintSha256!: string | pulumi.Output<string>;
    public publicKeyOpenssh!: string | pulumi.Output<string>;
    public publicKeyPem!: string | pulumi.Output<string>;
    public readyForRenewal!: boolean | pulumi.Output<boolean>;
    public rsaBits!: number | pulumi.Output<number>;
    public setAuthorityKeyId!: boolean | pulumi.Output<boolean>;
    public setSubjectKeyId!: boolean | pulumi.Output<boolean>;
    public subject?: tls.types.output.SelfSignedCertSubject | pulumi.Output<tls.types.output.SelfSignedCertSubject>;
    public uris?: string[] | pulumi.Output<string[]>;
    public validityEndTime!: string | pulumi.Output<string>;
    public validityPeriodHours!: number | pulumi.Output<number>;
    public validityStartTime!: string | pulumi.Output<string>;
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tls:RootCa", name, opts.urn ? { algorithm: undefined, allowedUses: undefined, cert: undefined, certPem: undefined, dnsNames: undefined, earlyRenewalHours: undefined, ecdsaCurve: undefined, ipAddresses: undefined, isCaCertificate: undefined, key: undefined, keyAlgorithm: undefined, privateKeyOpenssh: undefined, privateKeyPem: undefined, privateKeyPemPkcs8: undefined, publicKeyFingerprintMd5: undefined, publicKeyFingerprintSha256: undefined, publicKeyOpenssh: undefined, publicKeyPem: undefined, readyForRenewal: undefined, rsaBits: undefined, setAuthorityKeyId: undefined, setSubjectKeyId: undefined, subject: undefined, uris: undefined, validityEndTime: undefined, validityPeriodHours: undefined, validityStartTime: undefined } : { name, args, opts }, opts);
    }
}
export interface RootCaArgs {
    readonly algorithm?: pulumi.Input<AlgorithmInputs>;
    readonly dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
    readonly earlyRenewalHours?: pulumi.Input<number>;
    readonly ecdsaCurve?: pulumi.Input<EcdsaCurveInputs>;
    readonly ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    readonly rsaBits?: pulumi.Input<number>;
    readonly setAuthorityKeyId?: pulumi.Input<boolean>;
    readonly setSubjectKeyId?: pulumi.Input<boolean>;
    readonly subject?: pulumi.Input<tls.types.input.SelfSignedCertSubject>;
    readonly uris?: pulumi.Input<pulumi.Input<string>[]>;
    readonly validityPeriodHours: pulumi.Input<number>;
}
export abstract class Chmod<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | ChmodOptsOutputs);
    public delete?: (pulumi.Output<string> | ChmodOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | ChmodOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Chmod", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface ChmodArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | ChmodOptsInputs;
    readonly delete?: pulumi.Input<string> | ChmodOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | ChmodOptsInputs;
}
export abstract class Curl<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | CurlOptsOutputs);
    public delete?: (pulumi.Output<string> | CurlOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | CurlOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Curl", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface CurlArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | CurlOptsInputs;
    readonly delete?: pulumi.Input<string> | CurlOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | CurlOptsInputs;
}
export abstract class Etcdctl<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | EtcdctlOptsOutputs);
    public delete?: (pulumi.Output<string> | EtcdctlOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | EtcdctlOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Etcdctl", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface EtcdctlArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | EtcdctlOptsInputs;
    readonly delete?: pulumi.Input<string> | EtcdctlOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | EtcdctlOptsInputs;
}
export abstract class Hostnamectl<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | HostnamectlOptsOutputs);
    public delete?: (pulumi.Output<string> | HostnamectlOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | HostnamectlOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Hostnamectl", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface HostnamectlArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | HostnamectlOptsInputs;
    readonly delete?: pulumi.Input<string> | HostnamectlOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | HostnamectlOptsInputs;
}
export abstract class Mkdir<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | MkdirOptsOutputs);
    public delete?: (pulumi.Output<string> | MkdirOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | MkdirOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Mkdir", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface MkdirArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | MkdirOptsInputs;
    readonly delete?: pulumi.Input<string> | MkdirOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | MkdirOptsInputs;
}
export abstract class Mktemp<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | MktempOptsOutputs);
    public delete?: (pulumi.Output<string> | MktempOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | MktempOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Mktemp", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface MktempArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | MktempOptsInputs;
    readonly delete?: pulumi.Input<string> | MktempOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | MktempOptsInputs;
}
export abstract class Mv<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | MvOptsOutputs);
    public delete?: (pulumi.Output<string> | MvOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | MvOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Mv", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface MvArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | MvOptsInputs;
    readonly delete?: pulumi.Input<string> | MvOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | MvOptsInputs;
}
export abstract class Rm<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | RmOptsOutputs);
    public delete?: (pulumi.Output<string> | RmOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | RmOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Rm", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface RmArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | RmOptsInputs;
    readonly delete?: pulumi.Input<string> | RmOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | RmOptsInputs;
}
export abstract class Sed<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | SedOptsOutputs);
    public delete?: (pulumi.Output<string> | SedOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | SedOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Sed", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface SedArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | SedOptsInputs;
    readonly delete?: pulumi.Input<string> | SedOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | SedOptsInputs;
}
export abstract class Systemctl<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | SystemctlOptsOutputs);
    public delete?: (pulumi.Output<string> | SystemctlOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | SystemctlOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Systemctl", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface SystemctlArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | SystemctlOptsInputs;
    readonly delete?: pulumi.Input<string> | SystemctlOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | SystemctlOptsInputs;
}
export abstract class Tar<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | TarOptsOutputs);
    public delete?: (pulumi.Output<string> | TarOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | TarOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Tar", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface TarArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | TarOptsInputs;
    readonly delete?: pulumi.Input<string> | TarOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | TarOptsInputs;
}
export abstract class Tee<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | TeeOptsOutputs);
    public delete?: (pulumi.Output<string> | TeeOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | TeeOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Tee", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface TeeArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | TeeOptsInputs;
    readonly delete?: pulumi.Input<string> | TeeOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | TeeOptsInputs;
}
export abstract class Wget<TData = any> extends (pulumi.ComponentResource)<TData> {
    public binaryPath!: string | pulumi.Output<string>;
    public command!: command.remote.Command | pulumi.Output<command.remote.Command>;
    public connection!: command.types.output.remote.Connection | pulumi.Output<command.types.output.remote.Connection>;
    public create?: (pulumi.Output<string> | WgetOptsOutputs);
    public delete?: (pulumi.Output<string> | WgetOptsOutputs);
    public environment!: Record<string, string> | pulumi.Output<Record<string, string>>;
    public stderr!: string | pulumi.Output<string>;
    public stdin?: string | pulumi.Output<string>;
    public stdout!: string | pulumi.Output<string>;
    public triggers!: any[] | pulumi.Output<any[]>;
    public update?: (pulumi.Output<string> | WgetOptsOutputs);
    constructor(name: string, args: pulumi.Inputs, opts: pulumi.ComponentResourceOptions = {}) {
        super("kubernetes-the-hard-way:tools:Wget", name, opts.urn ? { binaryPath: undefined, command: undefined, connection: undefined, create: undefined, delete: undefined, environment: undefined, stderr: undefined, stdin: undefined, stdout: undefined, triggers: undefined, update: undefined } : { name, args, opts }, opts);
    }
}
export interface WgetArgs {
    readonly binaryPath?: pulumi.Input<string>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly create?: pulumi.Input<string> | WgetOptsInputs;
    readonly delete?: pulumi.Input<string> | WgetOptsInputs;
    readonly environment?: pulumi.Input<Record<string, pulumi.Input<string>>>;
    readonly stdin?: pulumi.Input<string>;
    readonly triggers?: pulumi.Input<pulumi.Input<any>[]>;
    readonly update?: pulumi.Input<string> | WgetOptsInputs;
}
export interface ClusterInputs {
    readonly certificateAuthorityData: pulumi.Input<string>;
    readonly server: pulumi.Input<string>;
}
export interface ClusterOutputs {
    readonly certificateAuthorityData: pulumi.Output<string>;
    readonly server: pulumi.Output<string>;
}
export interface ContextInputs {
    readonly cluster: pulumi.Input<string>;
    readonly user: pulumi.Input<string>;
}
export interface ContextOutputs {
    readonly cluster: pulumi.Output<string>;
    readonly user: pulumi.Output<string>;
}
export interface KubeconfigInputs {
    readonly clusters: pulumi.Input<pulumi.Input<ClusterInputs>[]>;
    readonly contexts: pulumi.Input<pulumi.Input<ContextInputs>[]>;
    readonly users: pulumi.Input<pulumi.Input<UserInputs>[]>;
}
export interface KubeconfigOutputs {
    readonly clusters: pulumi.Output<ClusterOutputs[]>;
    readonly contexts: pulumi.Output<ContextOutputs[]>;
    readonly users: pulumi.Output<UserOutputs[]>;
}
export interface KubeconfigAdminOptionsInputs {
    readonly publicIp?: pulumi.Input<string>;
    readonly type: string;
}
export interface KubeconfigAdminOptionsOutputs {
    readonly publicIp?: pulumi.Output<string>;
    readonly type: string;
}
export interface KubeconfigClusterInputs {
    readonly cluster: pulumi.Input<ClusterInputs>;
    readonly name: pulumi.Input<string>;
}
export interface KubeconfigClusterOutputs {
    readonly cluster: pulumi.Output<ClusterOutputs>;
    readonly name: pulumi.Output<string>;
}
export interface KubeconfigContextInputs {
    readonly context: pulumi.Input<ContextInputs>;
    readonly name: pulumi.Input<string>;
}
export interface KubeconfigContextOutputs {
    readonly context: pulumi.Output<ContextOutputs>;
    readonly name: pulumi.Output<string>;
}
export interface KubeconfigKubeControllerManagerOptionsInputs {
    readonly publicIp?: pulumi.Input<string>;
    readonly type: string;
}
export interface KubeconfigKubeControllerManagerOptionsOutputs {
    readonly publicIp?: pulumi.Output<string>;
    readonly type: string;
}
export interface KubeconfigKubeProxyOptionsInputs {
    readonly publicIp?: pulumi.Input<string>;
    readonly type: string;
}
export interface KubeconfigKubeProxyOptionsOutputs {
    readonly publicIp?: pulumi.Output<string>;
    readonly type: string;
}
export interface KubeconfigKubeSchedulerOptionsInputs {
    readonly publicIp?: pulumi.Input<string>;
    readonly type: string;
}
export interface KubeconfigKubeSchedulerOptionsOutputs {
    readonly publicIp?: pulumi.Output<string>;
    readonly type: string;
}
export type KubeconfigTypeInputs = "worker" | "kube-proxy" | "kube-controller-manager" | "kube-scheduler" | "admin";
export type KubeconfigTypeOutputs = "worker" | "kube-proxy" | "kube-controller-manager" | "kube-scheduler" | "admin";
export interface KubeconfigUserInputs {
    readonly name: pulumi.Input<string>;
    readonly user: pulumi.Input<UserInputs>;
}
export interface KubeconfigUserOutputs {
    readonly name: pulumi.Output<string>;
    readonly user: pulumi.Output<UserOutputs>;
}
export interface KubeconfigWorkerOptionsInputs {
    readonly name: pulumi.Input<string>;
    readonly publicIp: pulumi.Input<string>;
    readonly type?: string;
}
export interface KubeconfigWorkerOptionsOutputs {
    readonly name: pulumi.Output<string>;
    readonly publicIp: pulumi.Output<string>;
    readonly type?: string;
}
export interface PodManifestInputs {
    readonly apiVersion?: pulumi.Input<string>;
    readonly kind?: pulumi.Input<string>;
    readonly metadata?: pulumi.Input<kubernetes.types.input.meta.v1.ObjectMeta>;
    readonly spec?: pulumi.Input<kubernetes.types.input.core.v1.PodSpec>;
    readonly status?: pulumi.Input<kubernetes.types.input.core.v1.PodStatus>;
}
export interface PodManifestOutputs {
    readonly apiVersion?: pulumi.Output<string>;
    readonly kind?: pulumi.Output<string>;
    readonly metadata?: pulumi.Output<kubernetes.types.output.meta.v1.ObjectMeta>;
    readonly spec?: pulumi.Output<kubernetes.types.output.core.v1.PodSpec>;
    readonly status?: pulumi.Output<kubernetes.types.output.core.v1.PodStatus>;
}
export interface UserInputs {
    readonly clientCertificateData: pulumi.Input<string>;
    readonly clientKeyData: pulumi.Input<string>;
}
export interface UserOutputs {
    readonly clientCertificateData: pulumi.Output<string>;
    readonly clientKeyData: pulumi.Output<string>;
}
export type ArchitectureInputs = "amd64" | "arm64";
export type ArchitectureOutputs = "amd64" | "arm64";
export interface CniBridgeIpamInputs {
    readonly ranges?: pulumi.Input<pulumi.Input<Record<string, pulumi.Input<string>>>[]>;
    readonly routes?: pulumi.Input<pulumi.Input<Record<string, pulumi.Input<string>>>[]>;
    readonly type?: pulumi.Input<string>;
}
export interface CniBridgeIpamOutputs {
    readonly ranges?: pulumi.Output<Record<string, string>[]>;
    readonly routes?: pulumi.Output<Record<string, string>[]>;
    readonly type?: pulumi.Output<string>;
}
export interface EtcdConfigurationPropsInputs {
    readonly caFilePath: pulumi.Input<string>;
    readonly certFilePath: pulumi.Input<string>;
    readonly dataDirectory: pulumi.Input<string>;
    readonly etcdPath: pulumi.Input<string>;
    readonly internalIp: pulumi.Input<string>;
    readonly keyFilePath: pulumi.Input<string>;
    readonly name: pulumi.Input<string>;
}
export interface EtcdConfigurationPropsOutputs {
    readonly caFilePath: pulumi.Output<string>;
    readonly certFilePath: pulumi.Output<string>;
    readonly dataDirectory: pulumi.Output<string>;
    readonly etcdPath: pulumi.Output<string>;
    readonly internalIp: pulumi.Output<string>;
    readonly keyFilePath: pulumi.Output<string>;
    readonly name: pulumi.Output<string>;
}
export interface EtcdNodeInputs {
    readonly architecture?: pulumi.Input<ArchitectureInputs>;
    readonly connection: pulumi.Input<command.types.input.remote.ConnectionArgs>;
    readonly internalIp: pulumi.Input<string>;
}
export interface EtcdNodeOutputs {
    readonly architecture?: pulumi.Output<ArchitectureOutputs>;
    readonly connection: pulumi.Output<command.types.output.remote.Connection>;
    readonly internalIp: pulumi.Output<string>;
}
export interface SystemdInstallSectionInputs {
    readonly wantedBy?: pulumi.Input<pulumi.Input<string>[]>;
}
export interface SystemdInstallSectionOutputs {
    readonly wantedBy?: pulumi.Output<string[]>;
}
export type SystemdServiceExitTypeInputs = "main" | "cgroup";
export type SystemdServiceExitTypeOutputs = "main" | "cgroup";
export type SystemdServiceRestartInputs = "no" | "on-success" | "on-failure" | "on-abnormal" | "on-watchdog" | "on-abort" | "always";
export type SystemdServiceRestartOutputs = "no" | "on-success" | "on-failure" | "on-abnormal" | "on-watchdog" | "on-abort" | "always";
export interface SystemdServiceSectionInputs {
    readonly execStart?: pulumi.Input<string>;
    readonly exitType?: pulumi.Input<SystemdServiceExitTypeInputs>;
    readonly restart?: pulumi.Input<SystemdServiceRestartInputs>;
    readonly restartSec?: pulumi.Input<string>;
    readonly type?: pulumi.Input<SystemdServiceTypeInputs>;
}
export interface SystemdServiceSectionOutputs {
    readonly execStart?: pulumi.Output<string>;
    readonly exitType?: pulumi.Output<SystemdServiceExitTypeOutputs>;
    readonly restart?: pulumi.Output<SystemdServiceRestartOutputs>;
    readonly restartSec?: pulumi.Output<string>;
    readonly type?: pulumi.Output<SystemdServiceTypeOutputs>;
}
export type SystemdServiceTypeInputs = "simple" | "exec" | "forking" | "oneshot" | "dbus" | "notify" | "notify-reload" | "idle";
export type SystemdServiceTypeOutputs = "simple" | "exec" | "forking" | "oneshot" | "dbus" | "notify" | "notify-reload" | "idle";
export interface SystemdUnitSectionInputs {
    readonly bindsTo?: pulumi.Input<pulumi.Input<string>[]>;
    readonly description?: pulumi.Input<string>;
    readonly documentation?: pulumi.Input<pulumi.Input<string>[]>;
    readonly requires?: pulumi.Input<pulumi.Input<string>[]>;
    readonly requisite?: pulumi.Input<pulumi.Input<string>[]>;
    readonly wants?: pulumi.Input<pulumi.Input<string>[]>;
}
export interface SystemdUnitSectionOutputs {
    readonly bindsTo?: pulumi.Output<string[]>;
    readonly description?: pulumi.Output<string>;
    readonly documentation?: pulumi.Output<string[]>;
    readonly requires?: pulumi.Output<string[]>;
    readonly requisite?: pulumi.Output<string[]>;
    readonly wants?: pulumi.Output<string[]>;
}
export type AlgorithmInputs = "RSA" | "ECDSA" | "ED25519";
export type AlgorithmOutputs = "RSA" | "ECDSA" | "ED25519";
export type AllowedUsageInputs = "cert_signing" | "client_auth" | "crl_signing" | "digital_signature" | "key_encipherment" | "server_auth";
export type AllowedUsageOutputs = "cert_signing" | "client_auth" | "crl_signing" | "digital_signature" | "key_encipherment" | "server_auth";
export interface BundleInputs {
    readonly caPem: pulumi.Input<string>;
    readonly certPem: pulumi.Input<string>;
    readonly keyPem: pulumi.Input<string>;
}
export interface BundleOutputs {
    readonly caPem: pulumi.Output<string>;
    readonly certPem: pulumi.Output<string>;
    readonly keyPem: pulumi.Output<string>;
}
export interface ClusterPkiNodeInputs {
    readonly ip: pulumi.Input<string>;
    readonly role: pulumi.Input<NodeRoleInputs>;
}
export interface ClusterPkiNodeOutputs {
    readonly ip: pulumi.Output<string>;
    readonly role: pulumi.Output<NodeRoleOutputs>;
}
export type EcdsaCurveInputs = "P224" | "P256" | "P384" | "P521";
export type EcdsaCurveOutputs = "P224" | "P256" | "P384" | "P521";
export interface KeyPairInputs {
    readonly cert: pulumi.Input<pulumi.Input<tls.LocallySignedCert> | pulumi.Input<tls.SelfSignedCert>>;
    readonly certPem: pulumi.Input<string>;
    readonly key: pulumi.Input<tls.PrivateKey>;
    readonly privateKeyPem: pulumi.Input<string>;
    readonly publicKeyPem: pulumi.Input<string>;
}
export interface KeyPairOutputs {
    readonly cert: pulumi.Output<pulumi.Output<tls.LocallySignedCert> | pulumi.Output<tls.SelfSignedCert>>;
    readonly certPem: pulumi.Output<string>;
    readonly key: pulumi.Output<tls.PrivateKey>;
    readonly privateKeyPem: pulumi.Output<string>;
    readonly publicKeyPem: pulumi.Output<string>;
}
export type NodeRoleInputs = "controlplane" | "worker";
export type NodeRoleOutputs = "controlplane" | "worker";
export interface ChmodOptsInputs {
    readonly changes?: pulumi.Input<boolean>;
    readonly files: pulumi.Input<pulumi.Input<string>[]>;
    readonly help?: pulumi.Input<boolean>;
    readonly mode: pulumi.Input<string>;
    readonly noPreserveRoot?: pulumi.Input<boolean>;
    readonly preserveRoot?: pulumi.Input<boolean>;
    readonly quiet?: pulumi.Input<boolean>;
    readonly recursive?: pulumi.Input<boolean>;
    readonly reference?: pulumi.Input<string>;
    readonly silent?: pulumi.Input<boolean>;
    readonly version?: pulumi.Input<boolean>;
}
export interface ChmodOptsOutputs {
    readonly changes?: pulumi.Output<boolean>;
    readonly files: pulumi.Output<string[]>;
    readonly help?: pulumi.Output<boolean>;
    readonly mode: pulumi.Output<string>;
    readonly noPreserveRoot?: pulumi.Output<boolean>;
    readonly preserveRoot?: pulumi.Output<boolean>;
    readonly quiet?: pulumi.Output<boolean>;
    readonly recursive?: pulumi.Output<boolean>;
    readonly reference?: pulumi.Output<string>;
    readonly silent?: pulumi.Output<boolean>;
    readonly version?: pulumi.Output<boolean>;
}
export type CommandLifecycleInputs = "create" | "update" | "delete";
export type CommandLifecycleOutputs = "create" | "update" | "delete";
export type CurlCertTypeInputs = "PEM" | "DER" | "ENG" | "P12";
export type CurlCertTypeOutputs = "PEM" | "DER" | "ENG" | "P12";
export type CurlDelegationLevelInputs = "none" | "policy" | "always";
export type CurlDelegationLevelOutputs = "none" | "policy" | "always";
export interface CurlOptsInputs {
    readonly abstractUnixSocket?: pulumi.Input<string>;
    readonly altSvc?: pulumi.Input<string>;
    readonly anyAuth?: pulumi.Input<boolean>;
    readonly append?: pulumi.Input<boolean>;
    readonly awsSigv4?: pulumi.Input<string>;
    readonly basic?: pulumi.Input<boolean>;
    readonly cacert?: pulumi.Input<string>;
    readonly capath?: pulumi.Input<string>;
    readonly cert?: pulumi.Input<string>;
    readonly certStatus?: pulumi.Input<boolean>;
    readonly certType?: pulumi.Input<CurlCertTypeInputs>;
    readonly ciphers?: pulumi.Input<string>;
    readonly compressed?: pulumi.Input<boolean>;
    readonly compressedSsh?: pulumi.Input<boolean>;
    readonly config?: pulumi.Input<string>;
    readonly connectTimeout?: pulumi.Input<number>;
    readonly connectTo?: pulumi.Input<string>;
    readonly continueAt?: pulumi.Input<string>;
    readonly cookie?: pulumi.Input<string>;
    readonly cookieJar?: pulumi.Input<string>;
    readonly createDirs?: pulumi.Input<boolean>;
    readonly createFileMode?: pulumi.Input<string>;
    readonly crlf?: pulumi.Input<boolean>;
    readonly crlfFile?: pulumi.Input<string>;
    readonly curves?: pulumi.Input<string>;
    readonly data?: pulumi.Input<string>;
    readonly dataAscii?: pulumi.Input<string>;
    readonly dataBinary?: pulumi.Input<string>;
    readonly dataRaw?: pulumi.Input<string>;
    readonly dataUrlEncode?: pulumi.Input<string>;
    readonly delegation?: pulumi.Input<CurlDelegationLevelInputs>;
    readonly digest?: pulumi.Input<boolean>;
    readonly disable?: pulumi.Input<boolean>;
    readonly disableEprt?: pulumi.Input<boolean>;
    readonly disableEpsv?: pulumi.Input<boolean>;
    readonly disallowUsernameInUrl?: pulumi.Input<boolean>;
    readonly dnsInterface?: pulumi.Input<string>;
    readonly dnsIpv4Addr?: pulumi.Input<string>;
    readonly dnsIpv6Addr?: pulumi.Input<string>;
    readonly dnsServers?: pulumi.Input<string>;
    readonly dohCertStatus?: pulumi.Input<boolean>;
    readonly dohInsecure?: pulumi.Input<boolean>;
    readonly dohUrl?: pulumi.Input<string>;
    readonly dumpHeader?: pulumi.Input<string>;
    readonly egdFile?: pulumi.Input<string>;
    readonly engine?: pulumi.Input<string>;
    readonly etagCompare?: pulumi.Input<string>;
    readonly etagSave?: pulumi.Input<string>;
    readonly expect100Timeout?: pulumi.Input<number>;
    readonly fail?: pulumi.Input<boolean>;
    readonly failEarly?: pulumi.Input<boolean>;
    readonly failWithBody?: pulumi.Input<boolean>;
    readonly falseStart?: pulumi.Input<boolean>;
    readonly form?: pulumi.Input<string>;
    readonly formEscape?: pulumi.Input<boolean>;
    readonly formName?: pulumi.Input<string>;
    readonly ftpAccount?: pulumi.Input<string>;
    readonly ftpAlternativeUser?: pulumi.Input<string>;
    readonly ftpCreateDirs?: pulumi.Input<boolean>;
    readonly ftpMethod?: pulumi.Input<string>;
    readonly ftpPasv?: pulumi.Input<boolean>;
    readonly ftpPort?: pulumi.Input<string>;
    readonly ftpPret?: pulumi.Input<boolean>;
    readonly ftpSkipPasvIp?: pulumi.Input<boolean>;
    readonly ftpSslCccMode?: pulumi.Input<string>;
    readonly urls: pulumi.Input<pulumi.Input<string>[]>;
}
export interface CurlOptsOutputs {
    readonly abstractUnixSocket?: pulumi.Output<string>;
    readonly altSvc?: pulumi.Output<string>;
    readonly anyAuth?: pulumi.Output<boolean>;
    readonly append?: pulumi.Output<boolean>;
    readonly awsSigv4?: pulumi.Output<string>;
    readonly basic?: pulumi.Output<boolean>;
    readonly cacert?: pulumi.Output<string>;
    readonly capath?: pulumi.Output<string>;
    readonly cert?: pulumi.Output<string>;
    readonly certStatus?: pulumi.Output<boolean>;
    readonly certType?: pulumi.Output<CurlCertTypeOutputs>;
    readonly ciphers?: pulumi.Output<string>;
    readonly compressed?: pulumi.Output<boolean>;
    readonly compressedSsh?: pulumi.Output<boolean>;
    readonly config?: pulumi.Output<string>;
    readonly connectTimeout?: pulumi.Output<number>;
    readonly connectTo?: pulumi.Output<string>;
    readonly continueAt?: pulumi.Output<string>;
    readonly cookie?: pulumi.Output<string>;
    readonly cookieJar?: pulumi.Output<string>;
    readonly createDirs?: pulumi.Output<boolean>;
    readonly createFileMode?: pulumi.Output<string>;
    readonly crlf?: pulumi.Output<boolean>;
    readonly crlfFile?: pulumi.Output<string>;
    readonly curves?: pulumi.Output<string>;
    readonly data?: pulumi.Output<string>;
    readonly dataAscii?: pulumi.Output<string>;
    readonly dataBinary?: pulumi.Output<string>;
    readonly dataRaw?: pulumi.Output<string>;
    readonly dataUrlEncode?: pulumi.Output<string>;
    readonly delegation?: pulumi.Output<CurlDelegationLevelOutputs>;
    readonly digest?: pulumi.Output<boolean>;
    readonly disable?: pulumi.Output<boolean>;
    readonly disableEprt?: pulumi.Output<boolean>;
    readonly disableEpsv?: pulumi.Output<boolean>;
    readonly disallowUsernameInUrl?: pulumi.Output<boolean>;
    readonly dnsInterface?: pulumi.Output<string>;
    readonly dnsIpv4Addr?: pulumi.Output<string>;
    readonly dnsIpv6Addr?: pulumi.Output<string>;
    readonly dnsServers?: pulumi.Output<string>;
    readonly dohCertStatus?: pulumi.Output<boolean>;
    readonly dohInsecure?: pulumi.Output<boolean>;
    readonly dohUrl?: pulumi.Output<string>;
    readonly dumpHeader?: pulumi.Output<string>;
    readonly egdFile?: pulumi.Output<string>;
    readonly engine?: pulumi.Output<string>;
    readonly etagCompare?: pulumi.Output<string>;
    readonly etagSave?: pulumi.Output<string>;
    readonly expect100Timeout?: pulumi.Output<number>;
    readonly fail?: pulumi.Output<boolean>;
    readonly failEarly?: pulumi.Output<boolean>;
    readonly failWithBody?: pulumi.Output<boolean>;
    readonly falseStart?: pulumi.Output<boolean>;
    readonly form?: pulumi.Output<string>;
    readonly formEscape?: pulumi.Output<boolean>;
    readonly formName?: pulumi.Output<string>;
    readonly ftpAccount?: pulumi.Output<string>;
    readonly ftpAlternativeUser?: pulumi.Output<string>;
    readonly ftpCreateDirs?: pulumi.Output<boolean>;
    readonly ftpMethod?: pulumi.Output<string>;
    readonly ftpPasv?: pulumi.Output<boolean>;
    readonly ftpPort?: pulumi.Output<string>;
    readonly ftpPret?: pulumi.Output<boolean>;
    readonly ftpSkipPasvIp?: pulumi.Output<boolean>;
    readonly ftpSslCccMode?: pulumi.Output<string>;
    readonly urls: pulumi.Output<string[]>;
}
export type EtcdctlCommandInputs = "member" | "list" | "version";
export type EtcdctlCommandOutputs = "member" | "list" | "version";
export interface EtcdctlOptsInputs {
    readonly caCert?: pulumi.Input<string>;
    readonly cert?: pulumi.Input<string>;
    readonly commands: pulumi.Input<EtcdctlCommandInputs>;
    readonly endpoints?: pulumi.Input<string>;
    readonly key?: pulumi.Input<string>;
}
export interface EtcdctlOptsOutputs {
    readonly caCert?: pulumi.Output<string>;
    readonly cert?: pulumi.Output<string>;
    readonly commands: pulumi.Output<EtcdctlCommandOutputs>;
    readonly endpoints?: pulumi.Output<string>;
    readonly key?: pulumi.Output<string>;
}
export type HostnamectlCommandInputs = "status" | "hostname" | "icon-name" | "chassis" | "deployment" | "location";
export type HostnamectlCommandOutputs = "status" | "hostname" | "icon-name" | "chassis" | "deployment" | "location";
export type HostnamectlJsonModeInputs = "short" | "pretty" | "off";
export type HostnamectlJsonModeOutputs = "short" | "pretty" | "off";
export interface HostnamectlOptsInputs {
    readonly arg?: pulumi.Input<string>;
    readonly command: pulumi.Input<HostnamectlCommandInputs>;
    readonly help?: pulumi.Input<boolean>;
    readonly host?: pulumi.Input<string>;
    readonly json?: pulumi.Input<HostnamectlJsonModeInputs>;
    readonly machine?: pulumi.Input<string>;
    readonly noAskPassword?: pulumi.Input<boolean>;
    readonly pretty?: pulumi.Input<boolean>;
    readonly static?: pulumi.Input<boolean>;
    readonly transient?: pulumi.Input<boolean>;
    readonly version?: pulumi.Input<boolean>;
}
export interface HostnamectlOptsOutputs {
    readonly arg?: pulumi.Output<string>;
    readonly command: pulumi.Output<HostnamectlCommandOutputs>;
    readonly help?: pulumi.Output<boolean>;
    readonly host?: pulumi.Output<string>;
    readonly json?: pulumi.Output<HostnamectlJsonModeOutputs>;
    readonly machine?: pulumi.Output<string>;
    readonly noAskPassword?: pulumi.Output<boolean>;
    readonly pretty?: pulumi.Output<boolean>;
    readonly static?: pulumi.Output<boolean>;
    readonly transient?: pulumi.Output<boolean>;
    readonly version?: pulumi.Output<boolean>;
}
export interface MkdirOptsInputs {
    readonly directory: pulumi.Input<string>;
    readonly parents?: pulumi.Input<boolean>;
    readonly removeOnDelete?: pulumi.Input<boolean>;
}
export interface MkdirOptsOutputs {
    readonly directory: pulumi.Output<string>;
    readonly parents?: pulumi.Output<boolean>;
    readonly removeOnDelete?: pulumi.Output<boolean>;
}
export interface MktempOptsInputs {
    readonly directory?: pulumi.Input<boolean>;
    readonly dryRun?: pulumi.Input<boolean>;
    readonly quiet?: pulumi.Input<boolean>;
    readonly suffix?: pulumi.Input<string>;
    readonly template?: pulumi.Input<string>;
    readonly tmpdir?: pulumi.Input<string>;
}
export interface MktempOptsOutputs {
    readonly directory?: pulumi.Output<boolean>;
    readonly dryRun?: pulumi.Output<boolean>;
    readonly quiet?: pulumi.Output<boolean>;
    readonly suffix?: pulumi.Output<string>;
    readonly template?: pulumi.Output<string>;
    readonly tmpdir?: pulumi.Output<string>;
}
export interface MvOptsInputs {
    readonly backup?: boolean;
    readonly context?: pulumi.Input<boolean>;
    readonly control?: pulumi.Input<boolean>;
    readonly dest?: pulumi.Input<string>;
    readonly directory?: pulumi.Input<string>;
    readonly force?: pulumi.Input<boolean>;
    readonly noClobber?: pulumi.Input<boolean>;
    readonly noTargetDirectory?: pulumi.Input<boolean>;
    readonly source: pulumi.Input<pulumi.Input<string>[]>;
    readonly stripTrailingSlashes?: pulumi.Input<boolean>;
    readonly suffix?: pulumi.Input<string>;
    readonly targetDirectory?: pulumi.Input<boolean>;
    readonly update?: pulumi.Input<boolean>;
    readonly verbose?: pulumi.Input<boolean>;
}
export interface MvOptsOutputs {
    readonly backup?: boolean;
    readonly context?: pulumi.Output<boolean>;
    readonly control?: pulumi.Output<boolean>;
    readonly dest?: pulumi.Output<string>;
    readonly directory?: pulumi.Output<string>;
    readonly force?: pulumi.Output<boolean>;
    readonly noClobber?: pulumi.Output<boolean>;
    readonly noTargetDirectory?: pulumi.Output<boolean>;
    readonly source: pulumi.Output<string[]>;
    readonly stripTrailingSlashes?: pulumi.Output<boolean>;
    readonly suffix?: pulumi.Output<string>;
    readonly targetDirectory?: pulumi.Output<boolean>;
    readonly update?: pulumi.Output<boolean>;
    readonly verbose?: pulumi.Output<boolean>;
}
export interface RmOptsInputs {
    readonly dir?: pulumi.Input<boolean>;
    readonly files: pulumi.Input<pulumi.Input<string>[]>;
    readonly force?: pulumi.Input<boolean>;
    readonly onDelete?: pulumi.Input<boolean>;
    readonly recursive?: pulumi.Input<boolean>;
    readonly verbose?: pulumi.Input<boolean>;
}
export interface RmOptsOutputs {
    readonly dir?: pulumi.Output<boolean>;
    readonly files: pulumi.Output<string[]>;
    readonly force?: pulumi.Output<boolean>;
    readonly onDelete?: pulumi.Output<boolean>;
    readonly recursive?: pulumi.Output<boolean>;
    readonly verbose?: pulumi.Output<boolean>;
}
export interface SedOptsInputs {
    readonly debug?: pulumi.Input<boolean>;
    readonly expressions?: pulumi.Input<pulumi.Input<string>[]>;
    readonly files?: pulumi.Input<pulumi.Input<string>[]>;
    readonly followSymlinks?: pulumi.Input<boolean>;
    readonly help?: pulumi.Input<boolean>;
    readonly inPlace?: pulumi.Input<string>;
    readonly inputFiles?: pulumi.Input<pulumi.Input<string>[]>;
    readonly lineLength?: pulumi.Input<number>;
    readonly nullData?: pulumi.Input<boolean>;
    readonly posix?: pulumi.Input<boolean>;
    readonly quiet?: pulumi.Input<boolean>;
    readonly regexpExtended?: pulumi.Input<boolean>;
    readonly sandbox?: pulumi.Input<boolean>;
    readonly script?: pulumi.Input<string>;
    readonly separate?: pulumi.Input<boolean>;
    readonly silent?: pulumi.Input<boolean>;
    readonly unbuffered?: pulumi.Input<boolean>;
    readonly version?: pulumi.Input<boolean>;
}
export interface SedOptsOutputs {
    readonly debug?: pulumi.Output<boolean>;
    readonly expressions?: pulumi.Output<string[]>;
    readonly files?: pulumi.Output<string[]>;
    readonly followSymlinks?: pulumi.Output<boolean>;
    readonly help?: pulumi.Output<boolean>;
    readonly inPlace?: pulumi.Output<string>;
    readonly inputFiles?: pulumi.Output<string[]>;
    readonly lineLength?: pulumi.Output<number>;
    readonly nullData?: pulumi.Output<boolean>;
    readonly posix?: pulumi.Output<boolean>;
    readonly quiet?: pulumi.Output<boolean>;
    readonly regexpExtended?: pulumi.Output<boolean>;
    readonly sandbox?: pulumi.Output<boolean>;
    readonly script?: pulumi.Output<string>;
    readonly separate?: pulumi.Output<boolean>;
    readonly silent?: pulumi.Output<boolean>;
    readonly unbuffered?: pulumi.Output<boolean>;
    readonly version?: pulumi.Output<boolean>;
}
export type SystemctlCommandInputs = "bind" | "cat" | "clean" | "daemon-reload" | "disable" | "enable" | "freeze" | "is-active" | "is-enabled" | "is-failed" | "isolate" | "kill" | "list-automounts" | "list-dependencies" | "list-paths" | "list-sockets" | "list-timers" | "list-units" | "mask" | "mount-image" | "reenable" | "reload" | "reload-or-restart" | "restart" | "set-property" | "show" | "start" | "status" | "stop" | "thaw" | "try-reload-or-restart" | "try-restart" | "unmask";
export type SystemctlCommandOutputs = "bind" | "cat" | "clean" | "daemon-reload" | "disable" | "enable" | "freeze" | "is-active" | "is-enabled" | "is-failed" | "isolate" | "kill" | "list-automounts" | "list-dependencies" | "list-paths" | "list-sockets" | "list-timers" | "list-units" | "mask" | "mount-image" | "reenable" | "reload" | "reload-or-restart" | "restart" | "set-property" | "show" | "start" | "status" | "stop" | "thaw" | "try-reload-or-restart" | "try-restart" | "unmask";
export interface SystemctlOptsInputs {
    readonly command: SystemctlCommandInputs;
    readonly pattern?: pulumi.Input<string>;
    readonly unit?: pulumi.Input<string>;
}
export interface SystemctlOptsOutputs {
    readonly command: SystemctlCommandOutputs;
    readonly pattern?: pulumi.Output<string>;
    readonly unit?: pulumi.Output<string>;
}
export interface TarOptsInputs {
    readonly archive: pulumi.Input<string>;
    readonly directory?: pulumi.Input<string>;
    readonly extract?: pulumi.Input<boolean>;
    readonly files?: pulumi.Input<pulumi.Input<string>[]>;
    readonly gzip?: pulumi.Input<boolean>;
    readonly onDelete?: pulumi.Input<boolean>;
    readonly recursive?: pulumi.Input<boolean>;
    readonly stripComponents?: pulumi.Input<number>;
}
export interface TarOptsOutputs {
    readonly archive: pulumi.Output<string>;
    readonly directory?: pulumi.Output<string>;
    readonly extract?: pulumi.Output<boolean>;
    readonly files?: pulumi.Output<string[]>;
    readonly gzip?: pulumi.Output<boolean>;
    readonly onDelete?: pulumi.Output<boolean>;
    readonly recursive?: pulumi.Output<boolean>;
    readonly stripComponents?: pulumi.Output<number>;
}
export type TeeModeInputs = "warn" | "warn-nopipe" | "exit" | "exit-nopipe";
export type TeeModeOutputs = "warn" | "warn-nopipe" | "exit" | "exit-nopipe";
export interface TeeOptsInputs {
    readonly append?: pulumi.Input<boolean>;
    readonly files: pulumi.Input<pulumi.Input<string>[]>;
    readonly ignoreInterrupts?: pulumi.Input<boolean>;
    readonly outputError?: pulumi.Input<TeeModeInputs>;
    readonly pipe?: pulumi.Input<boolean>;
    readonly version?: pulumi.Input<boolean>;
}
export interface TeeOptsOutputs {
    readonly append?: pulumi.Output<boolean>;
    readonly files: pulumi.Output<string[]>;
    readonly ignoreInterrupts?: pulumi.Output<boolean>;
    readonly outputError?: pulumi.Output<TeeModeOutputs>;
    readonly pipe?: pulumi.Output<boolean>;
    readonly version?: pulumi.Output<boolean>;
}
export interface WgetOptsInputs {
    readonly directoryPrefix?: pulumi.Input<string>;
    readonly httpsOnly?: pulumi.Input<boolean>;
    readonly noVerbose?: pulumi.Input<boolean>;
    readonly outputDocument?: pulumi.Input<string>;
    readonly quiet?: pulumi.Input<boolean>;
    readonly timestamping?: pulumi.Input<boolean>;
    readonly url: pulumi.Input<pulumi.Input<string>[]>;
}
export interface WgetOptsOutputs {
    readonly directoryPrefix?: pulumi.Output<string>;
    readonly httpsOnly?: pulumi.Output<boolean>;
    readonly noVerbose?: pulumi.Output<boolean>;
    readonly outputDocument?: pulumi.Output<string>;
    readonly quiet?: pulumi.Output<boolean>;
    readonly timestamping?: pulumi.Output<boolean>;
    readonly url: pulumi.Output<string[]>;
}
export interface getKubeVipManifestInputs {
    readonly address: pulumi.Input<string>;
    readonly bgpAs?: pulumi.Input<number>;
    readonly bgpEnable?: pulumi.Input<boolean>;
    readonly bgpPeerAddress?: pulumi.Input<string>;
    readonly bgpPeerAs?: pulumi.Input<number>;
    readonly bgpPeerPass?: pulumi.Input<string>;
    readonly bgpPeers?: pulumi.Input<string>;
    readonly bgpRouterId?: pulumi.Input<string>;
    readonly cpEnable?: pulumi.Input<boolean>;
    readonly cpNamespace?: pulumi.Input<string>;
    readonly image?: pulumi.Input<string>;
    readonly kubeconfigPath: pulumi.Input<string>;
    readonly name?: pulumi.Input<string>;
    readonly namespace?: pulumi.Input<string>;
    readonly port?: pulumi.Input<number>;
    readonly svcEnable?: pulumi.Input<boolean>;
    readonly version?: pulumi.Input<string>;
    readonly vipArp?: pulumi.Input<boolean>;
    readonly vipCidr: pulumi.Input<number>;
    readonly vipDdns?: pulumi.Input<boolean>;
    readonly vipInterface?: pulumi.Input<string>;
    readonly vipLeaderElection?: pulumi.Input<boolean>;
    readonly vipLeaseDuration?: pulumi.Input<number>;
    readonly vipRenewDeadline?: pulumi.Input<number>;
    readonly vipRetryPeriod?: pulumi.Input<number>;
}
export interface getKubeVipManifestOutputs {
    readonly result: pulumi.Output<PodManifestOutputs>;
}
export interface getKubeconfigInputs {
    readonly caPem: pulumi.Input<string>;
    readonly options: pulumi.Input<KubeconfigAdminOptionsInputs> | pulumi.Input<KubeconfigKubeControllerManagerOptionsInputs> | pulumi.Input<KubeconfigKubeProxyOptionsInputs> | pulumi.Input<KubeconfigKubeSchedulerOptionsInputs> | pulumi.Input<KubeconfigWorkerOptionsInputs>;
}
export interface getKubeconfigOutputs {
    readonly result: pulumi.Output<KubeconfigOutputs>;
}
export interface ClusterPki_getKubeconfigInputs {
    readonly __self__: pulumi.Input<ClusterPki>;
    readonly options: pulumi.Input<KubeconfigAdminOptionsInputs> | pulumi.Input<KubeconfigKubeControllerManagerOptionsInputs> | pulumi.Input<KubeconfigKubeProxyOptionsInputs> | pulumi.Input<KubeconfigKubeSchedulerOptionsInputs> | pulumi.Input<KubeconfigWorkerOptionsInputs>;
}
export interface ClusterPki_getKubeconfigOutputs {
    readonly result: pulumi.Output<KubeconfigOutputs>;
}
