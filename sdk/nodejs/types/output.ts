// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";

import * as pulumiCommand from "@pulumi/command";
import * as pulumiKubernetes from "@pulumi/kubernetes";
import * as pulumiTls from "@pulumi/tls";
import * as utilities from "../utilities";

export namespace config {
    export interface Cluster {
        certificateAuthorityData: string;
        server: string;
    }

    export interface Context {
        cluster: string;
        user: string;
    }

    export interface Kubeconfig {
        clusters: outputs.config.Cluster[];
        contexts: outputs.config.Context[];
        users: outputs.config.User[];
    }

    /**
     * Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.
     *
     * This resource waits until its status is ready before registering success
     * for create/update, and populating output properties from the current state of the resource.
     * The following conditions are used to determine whether the resource creation has
     * succeeded or failed:
     *
     * 1. The Pod is scheduled ("PodScheduled"" '.status.condition' is true).
     * 2. The Pod is initialized ("Initialized" '.status.condition' is true).
     * 3. The Pod is ready ("Ready" '.status.condition' is true) and the '.status.phase' is
     *    set to "Running".
     * Or (for Jobs): The Pod succeeded ('.status.phase' set to "Succeeded").
     *
     * If the Pod has not reached a Ready state after 10 minutes, it will
     * time out and mark the resource update as Failed. You can override the default timeout value
     * by setting the 'customTimeouts' option on the resource.
     *
     * {{% examples %}}
     * ## Example Usage
     * {{% example %}}
     * ### Create a Pod with auto-naming
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * import * as kubernetes from "@pulumi/kubernetes";
     *
     * const pod = new kubernetes.core.v1.Pod("pod", {spec: {
     *     containers: [{
     *         image: "nginx:1.14.2",
     *         name: "nginx",
     *         ports: [{
     *             containerPort: 80,
     *         }],
     *     }],
     * }});
     * ```
     * ```python
     * import pulumi
     * import pulumi_kubernetes as kubernetes
     *
     * pod = kubernetes.core.v1.Pod("pod", spec=kubernetes.core.v1.PodSpecArgs(
     *     containers=[kubernetes.core.v1.ContainerArgs(
     *         image="nginx:1.14.2",
     *         name="nginx",
     *         ports=[kubernetes.core.v1.ContainerPortArgs(
     *             container_port=80,
     *         )],
     *     )],
     * ))
     * ```
     * ```csharp
     * using System.Collections.Generic;
     * using System.Linq;
     * using Pulumi;
     * using Kubernetes = Pulumi.Kubernetes;
     *
     * return await Deployment.RunAsync(() => 
     * {
     *     var pod = new Kubernetes.Core.V1.Pod("pod", new()
     *     {
     *         Spec = new Kubernetes.Types.Inputs.Core.V1.PodSpecArgs
     *         {
     *             Containers = new[]
     *             {
     *                 new Kubernetes.Types.Inputs.Core.V1.ContainerArgs
     *                 {
     *                     Image = "nginx:1.14.2",
     *                     Name = "nginx",
     *                     Ports = new[]
     *                     {
     *                         new Kubernetes.Types.Inputs.Core.V1.ContainerPortArgs
     *                         {
     *                             ContainerPortValue = 80,
     *                         },
     *                     },
     *                 },
     *             },
     *         },
     *     });
     *
     * });
     *
     * ```
     * ```go
     * package main
     *
     * import (
     * 	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/core/v1"
     * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
     * )
     *
     * func main() {
     * 	pulumi.Run(func(ctx *pulumi.Context) error {
     * 		_, err := corev1.NewPod(ctx, "pod", &corev1.PodArgs{
     * 			Spec: &corev1.PodSpecArgs{
     * 				Containers: corev1.ContainerArray{
     * 					&corev1.ContainerArgs{
     * 						Image: pulumi.String("nginx:1.14.2"),
     * 						Name:  pulumi.String("nginx"),
     * 						Ports: corev1.ContainerPortArray{
     * 							&corev1.ContainerPortArgs{
     * 								ContainerPort: pulumi.Int(80),
     * 							},
     * 						},
     * 					},
     * 				},
     * 			},
     * 		})
     * 		if err != nil {
     * 			return err
     * 		}
     * 		return nil
     * 	})
     * }
     * ```
     * ```java
     * package generated_program;
     *
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.kubernetes.core_v1.Pod;
     * import com.pulumi.kubernetes.core_v1.PodArgs;
     * import com.pulumi.kubernetes.core_v1.inputs.PodSpecArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     *
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     *
     *     public static void stack(Context ctx) {
     *         var pod = new Pod("pod", PodArgs.builder()        
     *             .spec(PodSpecArgs.builder()
     *                 .containers(ContainerArgs.builder()
     *                     .image("nginx:1.14.2")
     *                     .name("nginx")
     *                     .ports(ContainerPortArgs.builder()
     *                         .containerPort(80)
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     *
     *     }
     * }
     * ```
     * ```yaml
     * description: Create a Pod with auto-naming
     * name: yaml-example
     * resources:
     *     pod:
     *         properties:
     *             spec:
     *                 containers:
     *                     - image: nginx:1.14.2
     *                       name: nginx
     *                       ports:
     *                         - containerPort: 80
     *         type: kubernetes:core/v1:Pod
     * runtime: yaml
     * ```
     * {{% /example %}}
     * {{% example %}}
     * ### Create a Pod with a user-specified name
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * import * as kubernetes from "@pulumi/kubernetes";
     *
     * const pod = new kubernetes.core.v1.Pod("pod", {
     *     metadata: {
     *         name: "nginx",
     *     },
     *     spec: {
     *         containers: [{
     *             image: "nginx:1.14.2",
     *             name: "nginx",
     *             ports: [{
     *                 containerPort: 80,
     *             }],
     *         }],
     *     },
     * });
     * ```
     * ```python
     * import pulumi
     * import pulumi_kubernetes as kubernetes
     *
     * pod = kubernetes.core.v1.Pod("pod",
     *     metadata=kubernetes.meta.v1.ObjectMetaArgs(
     *         name="nginx",
     *     ),
     *     spec=kubernetes.core.v1.PodSpecArgs(
     *         containers=[kubernetes.core.v1.ContainerArgs(
     *             image="nginx:1.14.2",
     *             name="nginx",
     *             ports=[kubernetes.core.v1.ContainerPortArgs(
     *                 container_port=80,
     *             )],
     *         )],
     *     ))
     * ```
     * ```csharp
     * using System.Collections.Generic;
     * using System.Linq;
     * using Pulumi;
     * using Kubernetes = Pulumi.Kubernetes;
     *
     * return await Deployment.RunAsync(() => 
     * {
     *     var pod = new Kubernetes.Core.V1.Pod("pod", new()
     *     {
     *         Metadata = new Kubernetes.Types.Inputs.Meta.V1.ObjectMetaArgs
     *         {
     *             Name = "nginx",
     *         },
     *         Spec = new Kubernetes.Types.Inputs.Core.V1.PodSpecArgs
     *         {
     *             Containers = new[]
     *             {
     *                 new Kubernetes.Types.Inputs.Core.V1.ContainerArgs
     *                 {
     *                     Image = "nginx:1.14.2",
     *                     Name = "nginx",
     *                     Ports = new[]
     *                     {
     *                         new Kubernetes.Types.Inputs.Core.V1.ContainerPortArgs
     *                         {
     *                             ContainerPortValue = 80,
     *                         },
     *                     },
     *                 },
     *             },
     *         },
     *     });
     *
     * });
     *
     * ```
     * ```go
     * package main
     *
     * import (
     * 	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/core/v1"
     * 	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
     * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
     * )
     *
     * func main() {
     * 	pulumi.Run(func(ctx *pulumi.Context) error {
     * 		_, err := corev1.NewPod(ctx, "pod", &corev1.PodArgs{
     * 			Metadata: &metav1.ObjectMetaArgs{
     * 				Name: pulumi.String("nginx"),
     * 			},
     * 			Spec: &corev1.PodSpecArgs{
     * 				Containers: corev1.ContainerArray{
     * 					&corev1.ContainerArgs{
     * 						Image: pulumi.String("nginx:1.14.2"),
     * 						Name:  pulumi.String("nginx"),
     * 						Ports: corev1.ContainerPortArray{
     * 							&corev1.ContainerPortArgs{
     * 								ContainerPort: pulumi.Int(80),
     * 							},
     * 						},
     * 					},
     * 				},
     * 			},
     * 		})
     * 		if err != nil {
     * 			return err
     * 		}
     * 		return nil
     * 	})
     * }
     * ```
     * ```java
     * package generated_program;
     *
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.kubernetes.core_v1.Pod;
     * import com.pulumi.kubernetes.core_v1.PodArgs;
     * import com.pulumi.kubernetes.meta_v1.inputs.ObjectMetaArgs;
     * import com.pulumi.kubernetes.core_v1.inputs.PodSpecArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     *
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     *
     *     public static void stack(Context ctx) {
     *         var pod = new Pod("pod", PodArgs.builder()        
     *             .metadata(ObjectMetaArgs.builder()
     *                 .name("nginx")
     *                 .build())
     *             .spec(PodSpecArgs.builder()
     *                 .containers(ContainerArgs.builder()
     *                     .image("nginx:1.14.2")
     *                     .name("nginx")
     *                     .ports(ContainerPortArgs.builder()
     *                         .containerPort(80)
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     *
     *     }
     * }
     * ```
     * ```yaml
     * description: Create a Pod with a user-specified name
     * name: yaml-example
     * resources:
     *     pod:
     *         properties:
     *             metadata:
     *                 name: nginx
     *             spec:
     *                 containers:
     *                     - image: nginx:1.14.2
     *                       name: nginx
     *                       ports:
     *                         - containerPort: 80
     *         type: kubernetes:core/v1:Pod
     * runtime: yaml
     * ```
     * {{% /example %}}
     * {{% /examples %}}
     */
    export interface PodManifest {
        /**
         * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
         */
        apiVersion?: "v1";
        /**
         * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
         */
        kind?: "Pod";
        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        metadata?: pulumiKubernetes.types.output.meta.v1.ObjectMeta;
        /**
         * Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        spec?: pulumiKubernetes.types.output.core.v1.PodSpec;
        /**
         * Most recently observed status of the pod. This data may not be up to date. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        status?: pulumiKubernetes.types.output.core.v1.PodStatus;
    }

    export interface User {
        clientCertificateData: string;
        clientKeyData: string;
    }

}

export namespace remote {
    /**
     * The CNI plugins IPAM
     */
    export interface CniBridgeIpam {
        /**
         * IPAM ranges.
         */
        ranges?: {[key: string]: string}[];
        /**
         * IPAM routes.
         */
        routes?: {[key: string]: string}[];
        /**
         * CNI bridge IPAM type
         */
        type?: string;
    }

    /**
     * Props for resources that consume etcd configuration.
     */
    export interface EtcdConfigurationProps {
        /**
         * Path to the certificate authority file on the remote system.
         */
        caFilePath: string;
        /**
         * Path to the certificate file on the remote system.
         */
        certFilePath: string;
        /**
         * Etcd's data directory.
         */
        dataDirectory: string;
        /**
         * Path to the etcd binary.
         */
        etcdPath: string;
        /**
         * Internal IP of the etcd node.
         */
        internalIp: string;
        /**
         * Path to the private key file on the remote system.
         */
        keyFilePath: string;
        /**
         * Name of the etcd node.
         */
        name: string;
    }

    /**
     * Etcd node description.
     */
    export interface EtcdNode {
        /**
         * The CPU architecture of the node.
         */
        architecture?: enums.remote.Architecture;
        /**
         * The parameters with which to connect to the remote host.
         */
        connection: pulumiCommand.types.output.remote.Connection;
        /**
         * The internal IP of the node.
         */
        internalIp: string;
    }
    /**
     * etcdNodeProvideDefaults sets the appropriate defaults for EtcdNode
     */
    export function etcdNodeProvideDefaults(val: EtcdNode): EtcdNode {
        return {
            ...val,
            connection: pulumiCommand.types.output.remote.connectionProvideDefaults(val.connection),
        };
    }

    /**
     * https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#%5BInstall%5D%20Section%20Options
     */
    export interface SystemdInstallSection {
        /**
         * A symbolic link is created in the .wants/, .requires/, or .upholds/ directory of each of the listed units when this unit is installed by systemctl enable.
         */
        wantedBy?: string[];
    }

    /**
     * https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html#
     */
    export interface SystemdServiceSection {
        /**
         * Commands that are executed when this service is started.
         */
        execStart?: string;
        /**
         * Specifies when the manager should consider the service to be finished.
         */
        exitType?: enums.remote.SystemdServiceExitType;
        /**
         * Configures whether the service shall be restarted when the service process exits, is killed, or a timeout is reached.
         */
        restart?: enums.remote.SystemdServiceRestart;
        /**
         * Configures the time to sleep before restarting a service (as configured with Restart=).
         */
        restartSec?: string;
        /**
         * Configures the mechanism via which the service notifies the manager that the service start-up has finished.
         */
        type?: enums.remote.SystemdServiceType;
    }

    /**
     * https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#
     */
    export interface SystemdUnitSection {
        /**
         * Configures requirement dependencies, very similar in style to Requires=.
         */
        bindsTo?: string[];
        /**
         * A short human readable title of the unit.
         */
        description?: string;
        /**
         * A space-separated list of URIs referencing documentation for this unit or its configuration.
         */
        documentation?: string[];
        /**
         * Similar to Wants=, but declares a stronger requirement dependency.
         */
        requires?: string[];
        /**
         * Similar to Requires=. However, if the units listed here are not started already, they will not be started and the starting of this unit will fail immediately.
         */
        requisite?: string[];
        /**
         * Configures (weak) requirement dependencies on other units.
         */
        wants?: string[];
    }

}

export namespace tls {
    /**
     * A CA + Cert + Key bundle
     */
    export interface Bundle {
        /**
         * The PEM encoded certificate authority data.
         */
        caPem: string;
        /**
         * The PEM encoded certificate data.
         */
        certPem: string;
        /**
         * The PEM encoded private key data
         */
        keyPem: string;
    }

    /**
     * TODO
     */
    export interface ClusterPkiNode {
        /**
         * The IP address of the node
         */
        ip: string;
        /**
         * The role a node should be configured for
         */
        role: enums.tls.NodeRole;
    }

}

export namespace tools {
    /**
     * Abstraction over the `chmod` utility on a remote system.
     */
    export interface ChmodOpts {
        /**
         * Like verbose but report only when a change is made.
         */
        changes?: boolean;
        /**
         * Corresponds to the [FILE] argument.
         */
        files: string[];
        /**
         * Display help and exit.
         */
        help?: boolean;
        /**
         * Modes may be absolute or symbolic. An absolute mode is an octal number...
         */
        mode: string;
        /**
         * Do not treat '/' specially (the default).
         */
        noPreserveRoot?: boolean;
        /**
         * Fail to operate recursively on '/'.
         */
        preserveRoot?: boolean;
        /**
         * Suppress most error messages. Same as `silent`.
         */
        quiet?: boolean;
        /**
         * Change files and directories recursively.
         */
        recursive?: boolean;
        /**
         * Use RFILE's mode instead of specifying MODE values. RFILE is always dereferenced if a symbolic link.
         */
        reference?: string;
        /**
         * Suppress most error messages. Same as `quiet`.
         */
        silent?: boolean;
        /**
         * Output version information and exit.
         */
        version?: boolean;
    }

    /**
     * Abstraction over the `curl` utility on a remote system. Transfer a URL.
     */
    export interface CurlOpts {
        /**
         * (HTTP) Connect through an abstract Unix domain socket, instead of using the network.
         */
        abstractUnixSocket?: string;
        /**
         * (HTTPS)  This  option enables the alt-svc parser in curl.
         */
        altSvc?: string;
        /**
         * (HTTP) Tells curl to figure out authentication method by itself, and use the most secure one the remote site claims to support.
         */
        anyAuth?: boolean;
        /**
         * (FTP SFTP) When used in an upload, this makes curl append to the target file instead of overwriting it.
         */
        append?: boolean;
        /**
         * Use AWS V4 signature authentication in the transfer.
         */
        awsSigv4?: string;
        /**
         * (HTTP) Tells curl to use HTTP Basic authentication with the remote host.
         */
        basic?: boolean;
        /**
         * (TLS)  Tells curl to use the specified certificate file to verify the peer.
         */
        cacert?: string;
        /**
         * (TLS) Tells curl to use the specified certificate directory to verify the peer.
         */
        capath?: string;
        /**
         * (TLS)  Tells  curl to use the specified client certificate file when getting a file with HTTPS, FTPS or another SSL-based protocol.
         */
        cert?: string;
        /**
         * (TLS) Tells curl to verify the status of the server certificate by using the Certificate Status Request (aka. OCSP stapling) TLS extension.
         */
        certStatus?: boolean;
        /**
         * (TLS) Tells curl what type the provided client certificate is using.
         */
        certType?: enums.tools.CurlCertType;
        /**
         * (TLS) Specifies which ciphers to use in the connection.
         */
        ciphers?: string;
        /**
         * (HTTP) Request a compressed response using one of the algorithms curl supports, and automatically decompress the content.
         */
        compressed?: boolean;
        /**
         * (SCP SFTP) Enables built-in SSH compression.
         */
        compressedSsh?: boolean;
        /**
         * Specify a text file to read curl arguments from.
         */
        config?: string;
        /**
         * Maximum  time  in seconds that you allow curl's connection to take.
         */
        connectTimeout?: number;
        /**
         * For a request to the given HOST1:PORT1 pair, connect to HOST2:PORT2 instead.
         */
        connectTo?: string;
        /**
         * Continue/Resume a previous file transfer at the given offset.
         */
        continueAt?: string;
        /**
         * (HTTP) Pass the data to the HTTP server in the Cookie header.
         */
        cookie?: string;
        /**
         * (HTTP)  Specify  to which file you want curl to write all cookies after a completed operation.
         */
        cookieJar?: string;
        /**
         * When used in conjunction with the -o, --output option, curl will create the necessary local directory hierarchy as needed.
         */
        createDirs?: boolean;
        /**
         * (SFTP SCP FILE) When curl is used to create files remotely using one of the supported protocols, this option allows the user to set which 'mode' to set on the file at creation time, instead of the default 0644.
         */
        createFileMode?: string;
        /**
         * (FTP SMTP) Convert LF to CRLF in upload. Useful for MVS (OS/390).
         */
        crlf?: boolean;
        /**
         * (TLS) Provide a file using PEM format with a Certificate Revocation List that may specify peer certificates that are to be considered revoked.
         */
        crlfFile?: string;
        /**
         * (TLS)  Tells curl to request specific curves to use during SSL session establishment according to RFC 8422, 5.1.
         */
        curves?: string;
        /**
         * (HTTP  MQTT) Sends the specified data in a POST request to the HTTP server, in the same way that a browser does when a user has filled in an HTML form and presses the submit button.
         */
        data?: string;
        /**
         * (HTTP) This is just an alias for -d, --data.
         */
        dataAscii?: string;
        /**
         * (HTTP) This posts data exactly as specified with no extra processing whatsoever.
         */
        dataBinary?: string;
        /**
         * (HTTP) This posts data similarly to -d, --data but without the special interpretation of the @ character.
         */
        dataRaw?: string;
        /**
         * (HTTP) This posts data, similar to the other -d, --data options with the exception that this performs URL-encoding.
         */
        dataUrlEncode?: string;
        /**
         * (GSS/kerberos) Set LEVEL to tell the server what it is allowed to delegate when it comes to user credentials.
         */
        delegation?: enums.tools.CurlDelegationLevel;
        /**
         * (HTTP) Enables HTTP Digest authentication.
         */
        digest?: boolean;
        /**
         * If used as the first parameter on the command line, the curlrc config file will not be read and used.
         */
        disable?: boolean;
        /**
         * (FTP) Tell curl to disable the use of the EPRT and LPRT commands when doing active FTP transfers
         */
        disableEprt?: boolean;
        /**
         * (FTP)  Tell  curl to disable the use of the EPSV command when doing passive FTP transfers
         */
        disableEpsv?: boolean;
        /**
         * (HTTP) This tells curl to exit if passed a url containing a username.
         */
        disallowUsernameInUrl?: boolean;
        /**
         * (DNS)  Tell  curl  to send outgoing DNS requests through <interface>.
         */
        dnsInterface?: string;
        /**
         * (DNS) Tell curl to bind to <ip-address> when making IPv4 DNS requests, so that the DNS requests originate from this address.
         */
        dnsIpv4Addr?: string;
        /**
         * (DNS) Tell curl to bind to <ip-address> when making IPv6 DNS requests, so that the DNS requests originate from this address.
         */
        dnsIpv6Addr?: string;
        /**
         * Set the list of DNS servers to be used instead of the system default.
         */
        dnsServers?: string;
        /**
         * Same as --cert-status but used for DoH (DNS-over-HTTPS).
         */
        dohCertStatus?: boolean;
        /**
         * Same as -k, --insecure but used for DoH (DNS-over-HTTPS).
         */
        dohInsecure?: boolean;
        /**
         * Specifies which DNS-over-HTTPS (DoH) server to use to resolve hostnames, instead of using the default name resolver mechanism.
         */
        dohUrl?: string;
        /**
         * (HTTP FTP) Write the received protocol headers to the specified file.
         */
        dumpHeader?: string;
        /**
         * (TLS) Specify the path name to the Entropy Gathering Daemon socket.
         */
        egdFile?: string;
        /**
         * (TLS) Select the OpenSSL crypto engine to use for cipher operations.
         */
        engine?: string;
        /**
         * (HTTP) This option makes a conditional HTTP request for the specific ETag read from the given file by sending a custom If-None-Match header using the stored ETag.
         */
        etagCompare?: string;
        /**
         * (HTTP) This option saves an HTTP ETag to the specified file.
         */
        etagSave?: string;
        /**
         * (HTTP)  Maximum  time in seconds that you allow curl to wait for a 100-continue response when curl emits an Expects: 100-continue header in its request.
         */
        expect100Timeout?: number;
        /**
         * (HTTP) Fail silently (no output at all) on server errors.
         */
        fail?: boolean;
        /**
         * Fail and exit on the first detected transfer error.
         */
        failEarly?: boolean;
        /**
         * (HTTP)  Return an error on server errors where the HTTP response code is 400 or greater).
         */
        failWithBody?: boolean;
        /**
         * (TLS) Tells curl to use false start during the TLS handshake.
         */
        falseStart?: boolean;
        /**
         * (HTTP SMTP IMAP) For HTTP protocol family, this lets curl emulate a filled-in form in which a user has pressed the submit button.
         */
        form?: string;
        /**
         * (HTTP) Tells curl to pass on names of multipart form fields and files using backslash-escaping instead of percent-encoding.
         */
        formEscape?: boolean;
        /**
         * (HTTP SMTP IMAP) Similar to -F, --form except that the value string for the named parameter is used literally.
         */
        formName?: string;
        /**
         * (FTP) When an FTP server asks for 'account data' after user name and password has been provided, this data is sent off using the ACCT command.
         */
        ftpAccount?: string;
        /**
         * (FTP) If authenticating with the USER and PASS commands fails, send this command.
         */
        ftpAlternativeUser?: string;
        /**
         * (FTP  SFTP) When an FTP or SFTP URL/operation uses a path that does not currently exist on the server, the standard behavior of curl is to fail.
         */
        ftpCreateDirs?: boolean;
        /**
         * (FTP) Control what method curl should use to reach a file on an FTP(S) server.
         */
        ftpMethod?: string;
        /**
         * (FTP) Use passive mode for the data connection.
         */
        ftpPasv?: boolean;
        /**
         * (FTP)  Reverses  the  default  initiator/listener  roles  when connecting with FTP.
         */
        ftpPort?: string;
        /**
         * (FTP) Tell curl to send a PRET command before PASV (and EPSV).
         */
        ftpPret?: boolean;
        /**
         * (FTP)  Tell  curl  to  not use the IP address the server suggests in its response to curl's PASV command when curl connects the data connection.
         */
        ftpSkipPasvIp?: boolean;
        /**
         * (FTP) Sets the CCC mode. The passive mode will not initiate the shutdown, but instead wait for the server to do it, and will not reply to the shutdown from the  server.
         */
        ftpSslCccMode?: string;
        /**
         * Corresponds to the URLs argument.
         */
        urls: string[];
    }

    /**
     * Abstraction over the `etcdctl` utility on a remote system.
     */
    export interface EtcdctlOpts {
        /**
         * TODO
         */
        caCert?: string;
        /**
         * TODO
         */
        cert?: string;
        /**
         * TODO
         */
        commands: enums.tools.EtcdctlCommand;
        /**
         * TODO
         */
        endpoints?: string;
        /**
         * TODO
         */
        key?: string;
    }

    /**
     * Abstraction over the `hostnamectl` utility on a remote system.
     */
    export interface HostnamectlOpts {
        /**
         * The argument for the specified `command`.
         */
        arg?: string;
        /**
         * Corresponds to the {COMMAND} argument.
         */
        command: enums.tools.HostnamectlCommand;
        /**
         * Print a short help text and exit.
         */
        help?: boolean;
        /**
         * Execute the operation remotely. Specify a hostname, or a username and hostname separated by '@', to connect to.
         */
        host?: string;
        /**
         * Shows output formatted as JSON.
         */
        json?: enums.tools.HostnamectlJsonMode;
        /**
         * Execute operation on a local container. Specify a container name to connect to, optionally prefixed by a user name to connect as and a separating '@' character.
         */
        machine?: string;
        /**
         * Do not query the user for authentication for privileged operations.
         */
        noAskPassword?: boolean;
        /**
         * If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `transient`.
         */
        pretty?: boolean;
        /**
         * If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `transient` and `pretty`.
         */
        static?: boolean;
        /**
         * If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `pretty`.
         */
        transient?: boolean;
        /**
         * Print a short version string and exit.
         */
        version?: boolean;
    }

    /**
     * Abstraction over the `mkdir` utility on a remote system.
     */
    export interface MkdirOpts {
        /**
         * The fully qualified path of the directory on the remote system.
         */
        directory: string;
        /**
         * Corresponds to the `--parents` option.
         */
        parents?: boolean;
        /**
         * Remove the created directory when the `Mkdir` resource is deleted or updated.
         */
        removeOnDelete?: boolean;
    }

    /**
     * Abstraction over the `mktemp` utility on a remote system.
     */
    export interface MktempOpts {
        /**
         * Corresponds to the `--directory` option.
         */
        directory?: boolean;
        /**
         * Corresponds to the `--dry-run` option.
         */
        dryRun?: boolean;
        /**
         * Corresponds to the `--quiet` option.
         */
        quiet?: boolean;
        /**
         * Corresponds to the `--suffix` option.
         */
        suffix?: string;
        /**
         * Corresponds to the [TEMPLATE] argument.
         */
        template?: string;
        /**
         * Corresponds to the `--tmpdir` option.
         */
        tmpdir?: string;
    }

    /**
     * Abstraction over the `mv` utility on a remote system.
     */
    export interface MvOpts {
        /**
         * Corresponds to the `-b` and `--backup` options depending on whether [CONTROL] is supplied.
         */
        backup?: boolean;
        /**
         * Corresponds to the `--context` option.
         */
        context?: boolean;
        /**
         * Corresponds to the [CONTROL] argument for the `--backup` option.
         */
        control?: boolean;
        /**
         * Corresponds to the [DEST] argument.
         */
        dest?: string;
        /**
         * Corresponds to the [DIRECTORY] argument.
         */
        directory?: string;
        /**
         * Corresponds to the `--force` option.
         */
        force?: boolean;
        /**
         * Corresponds to the `--no-clobber` option.
         */
        noClobber?: boolean;
        /**
         * Corresponds to the `--no-target-directory` option.
         */
        noTargetDirectory?: boolean;
        /**
         * Corresponds to the [SOURCE] argument.
         */
        source: string[];
        /**
         * Corresponds to the `--strip-trailing-slashes` option.
         */
        stripTrailingSlashes?: boolean;
        /**
         * Corresponds to the `--suffix` option.
         */
        suffix?: string;
        /**
         * Corresponds to the `--target-directory` option.
         */
        targetDirectory?: boolean;
        /**
         * Corresponds to the `--update` option.
         */
        update?: boolean;
        /**
         * Corresponds to the `--verbose` option.
         */
        verbose?: boolean;
    }

    /**
     * Abstraction over the `rm` utility on a remote system.
     */
    export interface RmOpts {
        /**
         * Corresponds to the `--dir` option.
         */
        dir?: boolean;
        /**
         * Corresponds to the [FILE] argument.
         */
        files: string[];
        /**
         * Corresponds to the `--force` option.
         */
        force?: boolean;
        /**
         * Whether rm should be run when the resource is created or deleted.
         */
        onDelete?: boolean;
        /**
         * Corresponds to the `--recursive` option.
         */
        recursive?: boolean;
        /**
         * Corresponds to the `--verbose` option.
         */
        verbose?: boolean;
    }

    /**
     * Abstraction over the `sed` utility on a remote system.
     */
    export interface SedOpts {
        /**
         * annotate program execution.
         */
        debug?: boolean;
        /**
         * add the script to the commands to be executed.
         */
        expressions?: string[];
        /**
         * add the contents of script-file to the commands to be executed.
         */
        files?: string[];
        /**
         * follow symlinks when processing in place
         */
        followSymlinks?: boolean;
        /**
         * display this help and exit.
         */
        help?: boolean;
        /**
         * edit files in place (makes backup if SUFFIX supplied)
         */
        inPlace?: string;
        /**
         * corresponds to the [input-file]... argument(s).
         */
        inputFiles?: string[];
        /**
         * specify the desired line-wrap length for the `l' command
         */
        lineLength?: number;
        /**
         * separate lines by NUL characters
         */
        nullData?: boolean;
        /**
         * disable all GNU extensions.
         */
        posix?: boolean;
        /**
         * suppress automatic printing of pattern space. Same as `silent`.
         */
        quiet?: boolean;
        /**
         * use extended regular expressions in the script (for portability use POSIX -E).
         */
        regexpExtended?: boolean;
        /**
         * operate in sandbox mode (disable e/r/w commands).
         */
        sandbox?: boolean;
        /**
         * script only if no other script.
         */
        script?: string;
        /**
         * consider files as separate rather than as a single, continuous long stream.
         */
        separate?: boolean;
        /**
         * suppress automatic printing of pattern space. Same as `quiet`.
         */
        silent?: boolean;
        /**
         * load minimal amounts of data from the input files and flush the output buffers more often.
         */
        unbuffered?: boolean;
        /**
         * output version information and exit.
         */
        version?: boolean;
    }

    /**
     * Abstraction over the `systemctl` utility on a remote system.
     */
    export interface SystemctlOpts {
        /**
         * Corresponds to the COMMAND argument.
         */
        command: enums.tools.SystemctlCommand;
        /**
         * Corresponds to the [PATTERN] argument
         */
        pattern?: string;
        /**
         * Corresponds to the [UNIT...] argument.
         */
        unit?: string;
    }

    /**
     * Abstraction over the `tar` utility on a remote system.
     */
    export interface TarOpts {
        /**
         * Corresponds to the [ARCHIVE] argument.
         */
        archive: string;
        /**
         * Corresponds to the `--directory` option.
         */
        directory?: string;
        /**
         * Corresponds to the `--extract` option.
         */
        extract?: boolean;
        /**
         * Corresponds to the [FILE] argument.
         */
        files?: string[];
        /**
         * Corresponds to the `--gzip` option.
         */
        gzip?: boolean;
        /**
         * Whether rm should be run when the resource is created or deleted.
         */
        onDelete?: boolean;
        /**
         * Corresponds to the `--recursive` option.
         */
        recursive?: boolean;
        /**
         * Corresponds to the `--strip-components` option.
         */
        stripComponents?: number;
    }

    /**
     * Abstraction over the `rm` utility on a remote system.
     */
    export interface TeeOpts {
        /**
         * Append to the given FILEs, do not overwrite
         */
        append?: boolean;
        /**
         * Corresponds to the [FILE] argument.
         */
        files: string[];
        /**
         * Ignore interrupt signals.
         */
        ignoreInterrupts?: boolean;
        /**
         * Set behavior on write error.
         */
        outputError?: enums.tools.TeeMode;
        /**
         * Operate in a more appropriate MODE with pipes.
         */
        pipe?: boolean;
        /**
         * Output version information and exit.
         */
        version?: boolean;
    }

    /**
     * Abstraction over the `wget` utility on a remote system.
     */
    export interface WgetOpts {
        /**
         * The  directory prefix is the directory where all other files and subdirectories will be saved to, i.e. the top of the retrieval tree.  The default is . (the current directory).
         */
        directoryPrefix?: string;
        /**
         * When in recursive mode, only HTTPS links are followed.
         */
        httpsOnly?: boolean;
        /**
         * Turn off verbose without being completely quiet (use -q for that), which means that error messages and basic information still get printed.
         */
        noVerbose?: boolean;
        /**
         * The  documents  will  not  be  written  to the appropriate files, but all will be concatenated together and written to file.
         */
        outputDocument?: string;
        /**
         * Turn off Wget's output.
         */
        quiet?: boolean;
        /**
         * Turn on time-stamping.
         */
        timestamping?: boolean;
        /**
         * Corresponds to the [URL...] argument.
         */
        url: string[];
    }

}
