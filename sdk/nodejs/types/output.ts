// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";

import * as pulumiCommand from "@pulumi/command";
import * as pulumiKubernetes from "@pulumi/kubernetes";
import * as pulumiTls from "@pulumi/tls";
import * as utilities from "../utilities";

export namespace config {
    export interface Cluster {
        /**
         * TODO
         */
        certificateAuthorityData: string;
        /**
         * TODO
         */
        server: string;
    }

    /**
     * The CNI plugins IPAM
     */
    export interface CniBridgeIpam {
        /**
         * IPAM ranges.
         */
        ranges?: {[key: string]: string}[];
        /**
         * IPAM routes.
         */
        routes?: {[key: string]: string}[];
        /**
         * CNI bridge IPAM type
         */
        type?: string;
    }

    /**
     * TODO
     */
    export interface CniBridgePluginConfiguration {
        /**
         * Bridge name.
         */
        bridge: string;
        /**
         * The version of the bridge plugin.
         */
        cniVersion?: string;
        /**
         * IP masq.
         */
        ipMasq: boolean;
        /**
         * IPAM.
         */
        ipam: outputs.config.CniBridgeIpam;
        /**
         * Is gateway.
         */
        isGateway: boolean;
        /**
         * Plugin name.
         */
        name: string;
        /**
         * The subnet to use.
         */
        subnet: string;
        /**
         * Plugin type.
         */
        type: string;
    }

    /**
     * CNI loopback plugin configuration.
     */
    export interface CniLoopbackPluginConfiguration {
        /**
         * The plugin CNI version.
         */
        cniVersion: string;
        /**
         * The name of the plugin.
         */
        name: string;
        /**
         * The type of the plugin.
         */
        type: string;
    }

    /**
     * The containerd configuration.
     */
    export interface ContainerdConfiguration {
        /**
         * The cri configuration.
         */
        cri?: outputs.config.ContainerdCriPluginConfiguration;
    }

    /**
     * containerd cri plugin configuration.
     */
    export interface ContainerdCriPluginConfiguration {
        /**
         * cni configuration.
         */
        cni: outputs.config.ContainerdCriPluginConfigurationCni;
        /**
         * containerd configuration.
         */
        containerd: outputs.config.ContainerdCriPluginConfigurationContainerd;
    }

    /**
     * containerd cri plugin configuration.
     */
    export interface ContainerdCriPluginConfigurationCni {
        /**
         * bin_dir
         */
        binDir?: string;
        /**
         * conf_dir
         */
        confDir?: string;
    }

    /**
     * containerd cri plugin configuration.
     */
    export interface ContainerdCriPluginConfigurationContainerd {
        /**
         * default_runtime_name
         */
        defaultRuntimeName?: string;
        /**
         * The containerd runtime configuration.
         */
        runtimes?: outputs.config.ContainerdCriPluginConfigurationContainerdRunc;
        /**
         * snapshotter
         */
        snapshotter?: string;
    }

    /**
     * containerd cri runc plugin configuration.
     */
    export interface ContainerdCriPluginConfigurationContainerdRunc {
        /**
         * runc options.
         */
        options: outputs.config.ContainerdCriPluginConfigurationContainerdRuncOptions;
        /**
         * runtime_type
         */
        runtimeType?: string;
    }

    /**
     * containerd cri runc plugin configuration.
     */
    export interface ContainerdCriPluginConfigurationContainerdRuncOptions {
        /**
         * SystemdCgroup
         */
        systemdCgroup?: boolean;
    }

    export interface Context {
        /**
         * TODO
         */
        cluster: string;
        /**
         * TODO
         */
        user: string;
    }

    export interface KubeProxyConfiguration {
        apiVersion?: "kubeproxy.config.k8s.io/v1alpha1";
        clientConnection?: outputs.config.KubeProxyConfigurationClientConnection;
        /**
         * TODO
         */
        clusterCIDR: string;
        kind?: "KubeProxyConfiguration";
        /**
         * TODO
         */
        mode?: string;
    }

    export interface KubeProxyConfigurationClientConnection {
        /**
         * Path to the kubeconfig.
         */
        kubeconfig: string;
    }

    export interface Kubeconfig {
        clusters: outputs.config.Cluster[];
        contexts: outputs.config.Context[];
        users: outputs.config.User[];
    }

    export interface KubeletConfiguration {
        apiVersion: "kubelet.config.k8s.io/v1beta1";
        authentication: outputs.config.KubeletConfigurationAuthentication;
        authorization: outputs.config.KubeletConfigurationAuthorization;
        /**
         * TODO
         */
        cgroupDriver: string;
        /**
         * TODO
         */
        clusterDNS: string[];
        /**
         * TODO
         */
        clusterDomain: string;
        /**
         * TODO
         */
        containerRuntimeEndpoint: string;
        kind: "KubeletConfiguration";
        /**
         * TODO
         */
        podCIDR: string;
        /**
         * TODO
         */
        resolvConf: string;
        /**
         * TODO
         */
        runtimeRequestTimeout: string;
        /**
         * TODO
         */
        tlsCertFile: string;
        /**
         * TODO
         */
        tlsPrivateKeyFile: string;
    }

    export interface KubeletConfigurationAuthentication {
        anonymous: outputs.config.KubeletConfigurationAuthenticationAnonymous;
        webhook: outputs.config.KubeletConfigurationAuthenticationWebhook;
        x509: outputs.config.KubeletConfigurationAuthenticationx509;
    }

    export interface KubeletConfigurationAuthenticationAnonymous {
        /**
         * TODO
         */
        enabled: boolean;
    }

    export interface KubeletConfigurationAuthenticationWebhook {
        /**
         * TODO
         */
        enabled: boolean;
    }

    export interface KubeletConfigurationAuthenticationx509 {
        /**
         * TODO
         */
        clientCAFile: string;
    }

    export interface KubeletConfigurationAuthorization {
        mode: string;
    }

    /**
     * Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.
     *
     * This resource waits until its status is ready before registering success
     * for create/update, and populating output properties from the current state of the resource.
     * The following conditions are used to determine whether the resource creation has
     * succeeded or failed:
     *
     * 1. The Pod is scheduled ("PodScheduled"" '.status.condition' is true).
     * 2. The Pod is initialized ("Initialized" '.status.condition' is true).
     * 3. The Pod is ready ("Ready" '.status.condition' is true) and the '.status.phase' is
     *    set to "Running".
     * Or (for Jobs): The Pod succeeded ('.status.phase' set to "Succeeded").
     *
     * If the Pod has not reached a Ready state after 10 minutes, it will
     * time out and mark the resource update as Failed. You can override the default timeout value
     * by setting the 'customTimeouts' option on the resource.
     *
     * {{% examples %}}
     * ## Example Usage
     * {{% example %}}
     * ### Create a Pod with auto-naming
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * import * as kubernetes from "@pulumi/kubernetes";
     *
     * const pod = new kubernetes.core.v1.Pod("pod", {spec: {
     *     containers: [{
     *         image: "nginx:1.14.2",
     *         name: "nginx",
     *         ports: [{
     *             containerPort: 80,
     *         }],
     *     }],
     * }});
     * ```
     * ```python
     * import pulumi
     * import pulumi_kubernetes as kubernetes
     *
     * pod = kubernetes.core.v1.Pod("pod", spec=kubernetes.core.v1.PodSpecArgs(
     *     containers=[kubernetes.core.v1.ContainerArgs(
     *         image="nginx:1.14.2",
     *         name="nginx",
     *         ports=[kubernetes.core.v1.ContainerPortArgs(
     *             container_port=80,
     *         )],
     *     )],
     * ))
     * ```
     * ```csharp
     * using System.Collections.Generic;
     * using System.Linq;
     * using Pulumi;
     * using Kubernetes = Pulumi.Kubernetes;
     *
     * return await Deployment.RunAsync(() => 
     * {
     *     var pod = new Kubernetes.Core.V1.Pod("pod", new()
     *     {
     *         Spec = new Kubernetes.Types.Inputs.Core.V1.PodSpecArgs
     *         {
     *             Containers = new[]
     *             {
     *                 new Kubernetes.Types.Inputs.Core.V1.ContainerArgs
     *                 {
     *                     Image = "nginx:1.14.2",
     *                     Name = "nginx",
     *                     Ports = new[]
     *                     {
     *                         new Kubernetes.Types.Inputs.Core.V1.ContainerPortArgs
     *                         {
     *                             ContainerPortValue = 80,
     *                         },
     *                     },
     *                 },
     *             },
     *         },
     *     });
     *
     * });
     *
     * ```
     * ```go
     * package main
     *
     * import (
     * 	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/core/v1"
     * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
     * )
     *
     * func main() {
     * 	pulumi.Run(func(ctx *pulumi.Context) error {
     * 		_, err := corev1.NewPod(ctx, "pod", &corev1.PodArgs{
     * 			Spec: &corev1.PodSpecArgs{
     * 				Containers: corev1.ContainerArray{
     * 					&corev1.ContainerArgs{
     * 						Image: pulumi.String("nginx:1.14.2"),
     * 						Name:  pulumi.String("nginx"),
     * 						Ports: corev1.ContainerPortArray{
     * 							&corev1.ContainerPortArgs{
     * 								ContainerPort: pulumi.Int(80),
     * 							},
     * 						},
     * 					},
     * 				},
     * 			},
     * 		})
     * 		if err != nil {
     * 			return err
     * 		}
     * 		return nil
     * 	})
     * }
     * ```
     * ```java
     * package generated_program;
     *
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.kubernetes.core_v1.Pod;
     * import com.pulumi.kubernetes.core_v1.PodArgs;
     * import com.pulumi.kubernetes.core_v1.inputs.PodSpecArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     *
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     *
     *     public static void stack(Context ctx) {
     *         var pod = new Pod("pod", PodArgs.builder()        
     *             .spec(PodSpecArgs.builder()
     *                 .containers(ContainerArgs.builder()
     *                     .image("nginx:1.14.2")
     *                     .name("nginx")
     *                     .ports(ContainerPortArgs.builder()
     *                         .containerPort(80)
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     *
     *     }
     * }
     * ```
     * ```yaml
     * description: Create a Pod with auto-naming
     * name: yaml-example
     * resources:
     *     pod:
     *         properties:
     *             spec:
     *                 containers:
     *                     - image: nginx:1.14.2
     *                       name: nginx
     *                       ports:
     *                         - containerPort: 80
     *         type: kubernetes:core/v1:Pod
     * runtime: yaml
     * ```
     * {{% /example %}}
     * {{% example %}}
     * ### Create a Pod with a user-specified name
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * import * as kubernetes from "@pulumi/kubernetes";
     *
     * const pod = new kubernetes.core.v1.Pod("pod", {
     *     metadata: {
     *         name: "nginx",
     *     },
     *     spec: {
     *         containers: [{
     *             image: "nginx:1.14.2",
     *             name: "nginx",
     *             ports: [{
     *                 containerPort: 80,
     *             }],
     *         }],
     *     },
     * });
     * ```
     * ```python
     * import pulumi
     * import pulumi_kubernetes as kubernetes
     *
     * pod = kubernetes.core.v1.Pod("pod",
     *     metadata=kubernetes.meta.v1.ObjectMetaArgs(
     *         name="nginx",
     *     ),
     *     spec=kubernetes.core.v1.PodSpecArgs(
     *         containers=[kubernetes.core.v1.ContainerArgs(
     *             image="nginx:1.14.2",
     *             name="nginx",
     *             ports=[kubernetes.core.v1.ContainerPortArgs(
     *                 container_port=80,
     *             )],
     *         )],
     *     ))
     * ```
     * ```csharp
     * using System.Collections.Generic;
     * using System.Linq;
     * using Pulumi;
     * using Kubernetes = Pulumi.Kubernetes;
     *
     * return await Deployment.RunAsync(() => 
     * {
     *     var pod = new Kubernetes.Core.V1.Pod("pod", new()
     *     {
     *         Metadata = new Kubernetes.Types.Inputs.Meta.V1.ObjectMetaArgs
     *         {
     *             Name = "nginx",
     *         },
     *         Spec = new Kubernetes.Types.Inputs.Core.V1.PodSpecArgs
     *         {
     *             Containers = new[]
     *             {
     *                 new Kubernetes.Types.Inputs.Core.V1.ContainerArgs
     *                 {
     *                     Image = "nginx:1.14.2",
     *                     Name = "nginx",
     *                     Ports = new[]
     *                     {
     *                         new Kubernetes.Types.Inputs.Core.V1.ContainerPortArgs
     *                         {
     *                             ContainerPortValue = 80,
     *                         },
     *                     },
     *                 },
     *             },
     *         },
     *     });
     *
     * });
     *
     * ```
     * ```go
     * package main
     *
     * import (
     * 	corev1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/core/v1"
     * 	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
     * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
     * )
     *
     * func main() {
     * 	pulumi.Run(func(ctx *pulumi.Context) error {
     * 		_, err := corev1.NewPod(ctx, "pod", &corev1.PodArgs{
     * 			Metadata: &metav1.ObjectMetaArgs{
     * 				Name: pulumi.String("nginx"),
     * 			},
     * 			Spec: &corev1.PodSpecArgs{
     * 				Containers: corev1.ContainerArray{
     * 					&corev1.ContainerArgs{
     * 						Image: pulumi.String("nginx:1.14.2"),
     * 						Name:  pulumi.String("nginx"),
     * 						Ports: corev1.ContainerPortArray{
     * 							&corev1.ContainerPortArgs{
     * 								ContainerPort: pulumi.Int(80),
     * 							},
     * 						},
     * 					},
     * 				},
     * 			},
     * 		})
     * 		if err != nil {
     * 			return err
     * 		}
     * 		return nil
     * 	})
     * }
     * ```
     * ```java
     * package generated_program;
     *
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.kubernetes.core_v1.Pod;
     * import com.pulumi.kubernetes.core_v1.PodArgs;
     * import com.pulumi.kubernetes.meta_v1.inputs.ObjectMetaArgs;
     * import com.pulumi.kubernetes.core_v1.inputs.PodSpecArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     *
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     *
     *     public static void stack(Context ctx) {
     *         var pod = new Pod("pod", PodArgs.builder()        
     *             .metadata(ObjectMetaArgs.builder()
     *                 .name("nginx")
     *                 .build())
     *             .spec(PodSpecArgs.builder()
     *                 .containers(ContainerArgs.builder()
     *                     .image("nginx:1.14.2")
     *                     .name("nginx")
     *                     .ports(ContainerPortArgs.builder()
     *                         .containerPort(80)
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     *
     *     }
     * }
     * ```
     * ```yaml
     * description: Create a Pod with a user-specified name
     * name: yaml-example
     * resources:
     *     pod:
     *         properties:
     *             metadata:
     *                 name: nginx
     *             spec:
     *                 containers:
     *                     - image: nginx:1.14.2
     *                       name: nginx
     *                       ports:
     *                         - containerPort: 80
     *         type: kubernetes:core/v1:Pod
     * runtime: yaml
     * ```
     * {{% /example %}}
     * {{% /examples %}}
     */
    export interface PodManifest {
        /**
         * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
         */
        apiVersion?: "v1";
        /**
         * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
         */
        kind?: "Pod";
        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        metadata?: pulumiKubernetes.types.output.meta.v1.ObjectMeta;
        /**
         * Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        spec?: pulumiKubernetes.types.output.core.v1.PodSpec;
        /**
         * Most recently observed status of the pod. This data may not be up to date. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        status?: pulumiKubernetes.types.output.core.v1.PodStatus;
    }

    export interface User {
        /**
         * TODO
         */
        clientCertificateData: string;
        /**
         * TODO
         */
        clientKeyData: string;
    }

}

export namespace remote {
    /**
     * Props for resources that consume etcd configuration.
     */
    export interface EtcdConfigurationProps {
        /**
         * Path to the certificate authority file on the remote system.
         */
        caFilePath: string;
        /**
         * Path to the certificate file on the remote system.
         */
        certFilePath: string;
        /**
         * Etcd's data directory.
         */
        dataDirectory: string;
        /**
         * Path to the etcd binary.
         */
        etcdPath: string;
        /**
         * Internal IP of the etcd node.
         */
        internalIp: string;
        /**
         * Path to the private key file on the remote system.
         */
        keyFilePath: string;
        /**
         * Name of the etcd node.
         */
        name: string;
    }

    /**
     * Etcd node description.
     */
    export interface EtcdNode {
        /**
         * The CPU architecture of the node.
         */
        architecture?: enums.remote.Architecture;
        /**
         * The parameters with which to connect to the remote host.
         */
        connection: pulumiCommand.types.output.remote.Connection;
        /**
         * The internal IP of the node.
         */
        internalIp: string;
    }
    /**
     * etcdNodeProvideDefaults sets the appropriate defaults for EtcdNode
     */
    export function etcdNodeProvideDefaults(val: EtcdNode): EtcdNode {
        return {
            ...val,
            connection: pulumiCommand.types.output.remote.connectionProvideDefaults(val.connection),
        };
    }

    /**
     * Props for resources that consume kube-proxy configuration.
     */
    export interface KubeProxyConfigurationProps {
        /**
         * Path to the kube proxy configuration file
         */
        configurationFilePath: string;
        /**
         * Path to the kube-proxy binary.
         */
        kubeProxyPath: string;
    }

    /**
     * Props for resources that consume kubelet configuration.
     */
    export interface KubeletConfigurationProps {
        /**
         * Path to the kubelet configuration.
         */
        configurationFilePath: string;
        /**
         * Path to the kubeconfig the kubelet will use
         */
        kubeconfigPath: string;
        /**
         * Path to the kubelet binary.
         */
        kubeletPath: string;
        /**
         * Whether to register the node. Defaults to `true`.
         */
        registerNode: boolean;
        /**
         * Verbosity. Defaults to `2`.
         */
        v: number;
    }

    /**
     * https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#%5BInstall%5D%20Section%20Options
     */
    export interface SystemdInstallSection {
        /**
         * A symbolic link is created in the .wants/, .requires/, or .upholds/ directory of each of the listed units when this unit is installed by systemctl enable.
         */
        wantedBy?: string[];
    }

    /**
     * https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html#
     */
    export interface SystemdServiceSection {
        /**
         * Turns on delegation of further resource control partitioning to processes of the unit.
         */
        delegate?: enums.remote.SystemdDelegate;
        environment?: string[];
        /**
         * Commands that are executed when this service is started.
         */
        execStart?: string;
        /**
         * Additional commands that are executed before the command in ExecStart=.
         */
        execStartPre?: string;
        /**
         * Specifies when the manager should consider the service to be finished.
         */
        exitType?: enums.remote.SystemdServiceExitType;
        /**
         * Specifies how processes of this unit shall be killed.
         */
        killMode?: enums.remote.SystemdKillMode;
        /**
         * https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#Process%20Properties
         */
        limitCore?: string;
        /**
         * https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#Process%20Properties
         */
        limitNProc?: string;
        /**
         * https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#Process%20Properties
         */
        limitNoFile?: number;
        /**
         * https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#OOMScoreAdjust=
         */
        oomScoreAdjust?: number;
        /**
         * Configures whether the service shall be restarted when the service process exits, is killed, or a timeout is reached.
         */
        restart?: enums.remote.SystemdServiceRestart;
        /**
         * Configures the time to sleep before restarting a service (as configured with Restart=).
         */
        restartSec?: number;
        /**
         * Configure unit start rate limiting. Units which are started more than burst times within an interval time span are not permitted to start any more. Use StartLimitIntervalSec= to configure the checking interval and StartLimitBurst= to configure how many starts per interval are allowed.
         */
        startLimitInterval?: number;
        /**
         * Configures the mechanism via which the service notifies the manager that the service start-up has finished.
         */
        type?: enums.remote.SystemdServiceType;
    }

    /**
     * https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#
     */
    export interface SystemdUnitSection {
        /**
         * Those two settings configure ordering dependencies between units.
         */
        after?: string[];
        /**
         * Those two settings configure ordering dependencies between units.
         */
        before?: string[];
        /**
         * Configures requirement dependencies, very similar in style to Requires=.
         */
        bindsTo?: string[];
        /**
         * A short human readable title of the unit.
         */
        description?: string;
        /**
         * A space-separated list of URIs referencing documentation for this unit or its configuration.
         */
        documentation?: string[];
        /**
         * Similar to Wants=, but declares a stronger requirement dependency.
         */
        requires?: string[];
        /**
         * Similar to Requires=. However, if the units listed here are not started already, they will not be started and the starting of this unit will fail immediately.
         */
        requisite?: string[];
        /**
         * Configures (weak) requirement dependencies on other units.
         */
        wants?: string[];
    }

}

export namespace tls {
    /**
     * A CA + Cert + Key bundle
     */
    export interface Bundle {
        /**
         * The PEM encoded certificate authority data.
         */
        caPem: string;
        /**
         * The PEM encoded certificate data.
         */
        certPem: string;
        /**
         * The PEM encoded private key data
         */
        keyPem: string;
    }

    /**
     * TODO
     */
    export interface ClusterPkiNode {
        /**
         * The IP address of the node
         */
        ip: string;
        /**
         * The role a node should be configured for
         */
        role: enums.tls.NodeRole;
    }

}

export namespace tools {
    /**
     * Abstraction over the `chmod` utility on a remote system.
     */
    export interface ChmodOpts {
        /**
         * Like verbose but report only when a change is made.
         */
        changes?: boolean;
        /**
         * Corresponds to the [FILE] argument.
         */
        files: string[];
        /**
         * Display help and exit.
         */
        help?: boolean;
        /**
         * Modes may be absolute or symbolic. An absolute mode is an octal number...
         */
        mode: string;
        /**
         * Do not treat '/' specially (the default).
         */
        noPreserveRoot?: boolean;
        /**
         * Fail to operate recursively on '/'.
         */
        preserveRoot?: boolean;
        /**
         * Suppress most error messages. Same as `silent`.
         */
        quiet?: boolean;
        /**
         * Change files and directories recursively.
         */
        recursive?: boolean;
        /**
         * Use RFILE's mode instead of specifying MODE values. RFILE is always dereferenced if a symbolic link.
         */
        reference?: string;
        /**
         * Suppress most error messages. Same as `quiet`.
         */
        silent?: boolean;
        /**
         * Output version information and exit.
         */
        version?: boolean;
    }

    /**
     * Abstraction over the `etcdctl` utility on a remote system.
     */
    export interface EtcdctlOpts {
        /**
         * TODO
         */
        caCert?: string;
        /**
         * TODO
         */
        cert?: string;
        /**
         * TODO
         */
        commands: enums.tools.EtcdctlCommand;
        /**
         * TODO
         */
        endpoints?: string;
        /**
         * TODO
         */
        key?: string;
    }

    /**
     * Abstraction over the `hostnamectl` utility on a remote system.
     */
    export interface HostnamectlOpts {
        /**
         * The argument for the specified `command`.
         */
        arg?: string;
        /**
         * Corresponds to the {COMMAND} argument.
         */
        command: enums.tools.HostnamectlCommand;
        /**
         * Print a short help text and exit.
         */
        help?: boolean;
        /**
         * Execute the operation remotely. Specify a hostname, or a username and hostname separated by '@', to connect to.
         */
        host?: string;
        /**
         * Shows output formatted as JSON.
         */
        json?: enums.tools.HostnamectlJsonMode;
        /**
         * Execute operation on a local container. Specify a container name to connect to, optionally prefixed by a user name to connect as and a separating '@' character.
         */
        machine?: string;
        /**
         * Do not query the user for authentication for privileged operations.
         */
        noAskPassword?: boolean;
        /**
         * If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `transient`.
         */
        pretty?: boolean;
        /**
         * If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `transient` and `pretty`.
         */
        static?: boolean;
        /**
         * If status is invoked (or no explicit command is given) and one of these switches is specified, hostnamectl will print out just this selected hostname. Same as `static` and `pretty`.
         */
        transient?: boolean;
        /**
         * Print a short version string and exit.
         */
        version?: boolean;
    }

    /**
     * Abstraction over the `mkdir` utility on a remote system.
     */
    export interface MkdirOpts {
        /**
         * The fully qualified path of the directory on the remote system.
         */
        directory: string;
        /**
         * Corresponds to the `--parents` option.
         */
        parents?: boolean;
        /**
         * Remove the created directory when the `Mkdir` resource is deleted or updated.
         */
        removeOnDelete?: boolean;
    }

    /**
     * Abstraction over the `mktemp` utility on a remote system.
     */
    export interface MktempOpts {
        /**
         * Corresponds to the `--directory` option.
         */
        directory?: boolean;
        /**
         * Corresponds to the `--dry-run` option.
         */
        dryRun?: boolean;
        /**
         * Corresponds to the `--quiet` option.
         */
        quiet?: boolean;
        /**
         * Corresponds to the `--suffix` option.
         */
        suffix?: string;
        /**
         * Corresponds to the [TEMPLATE] argument.
         */
        template?: string;
        /**
         * Corresponds to the `--tmpdir` option.
         */
        tmpdir?: string;
    }

    /**
     * Abstraction over the `mv` utility on a remote system.
     */
    export interface MvOpts {
        /**
         * Corresponds to the `-b` and `--backup` options depending on whether [CONTROL] is supplied.
         */
        backup?: boolean;
        /**
         * Corresponds to the `--context` option.
         */
        context?: boolean;
        /**
         * Corresponds to the [CONTROL] argument for the `--backup` option.
         */
        control?: boolean;
        /**
         * Corresponds to the [DEST] argument.
         */
        dest?: string;
        /**
         * Corresponds to the [DIRECTORY] argument.
         */
        directory?: string;
        /**
         * Corresponds to the `--force` option.
         */
        force?: boolean;
        /**
         * Corresponds to the `--no-clobber` option.
         */
        noClobber?: boolean;
        /**
         * Corresponds to the `--no-target-directory` option.
         */
        noTargetDirectory?: boolean;
        /**
         * Corresponds to the [SOURCE] argument.
         */
        source: string[];
        /**
         * Corresponds to the `--strip-trailing-slashes` option.
         */
        stripTrailingSlashes?: boolean;
        /**
         * Corresponds to the `--suffix` option.
         */
        suffix?: string;
        /**
         * Corresponds to the `--target-directory` option.
         */
        targetDirectory?: boolean;
        /**
         * Corresponds to the `--update` option.
         */
        update?: boolean;
        /**
         * Corresponds to the `--verbose` option.
         */
        verbose?: boolean;
    }

    /**
     * Abstraction over the `rm` utility on a remote system.
     */
    export interface RmOpts {
        /**
         * Corresponds to the `--dir` option.
         */
        dir?: boolean;
        /**
         * Corresponds to the [FILE] argument.
         */
        files: string[];
        /**
         * Corresponds to the `--force` option.
         */
        force?: boolean;
        /**
         * Whether rm should be run when the resource is created or deleted.
         */
        onDelete?: boolean;
        /**
         * Corresponds to the `--recursive` option.
         */
        recursive?: boolean;
        /**
         * Corresponds to the `--verbose` option.
         */
        verbose?: boolean;
    }

    /**
     * Abstraction over the `sed` utility on a remote system.
     */
    export interface SedOpts {
        /**
         * annotate program execution.
         */
        debug?: boolean;
        /**
         * add the script to the commands to be executed.
         */
        expressions?: string[];
        /**
         * add the contents of script-file to the commands to be executed.
         */
        files?: string[];
        /**
         * follow symlinks when processing in place
         */
        followSymlinks?: boolean;
        /**
         * display this help and exit.
         */
        help?: boolean;
        /**
         * edit files in place (makes backup if SUFFIX supplied)
         */
        inPlace?: string;
        /**
         * corresponds to the [input-file]... argument(s).
         */
        inputFiles?: string[];
        /**
         * specify the desired line-wrap length for the `l' command
         */
        lineLength?: number;
        /**
         * separate lines by NUL characters
         */
        nullData?: boolean;
        /**
         * disable all GNU extensions.
         */
        posix?: boolean;
        /**
         * suppress automatic printing of pattern space. Same as `silent`.
         */
        quiet?: boolean;
        /**
         * use extended regular expressions in the script (for portability use POSIX -E).
         */
        regexpExtended?: boolean;
        /**
         * operate in sandbox mode (disable e/r/w commands).
         */
        sandbox?: boolean;
        /**
         * script only if no other script.
         */
        script?: string;
        /**
         * consider files as separate rather than as a single, continuous long stream.
         */
        separate?: boolean;
        /**
         * suppress automatic printing of pattern space. Same as `quiet`.
         */
        silent?: boolean;
        /**
         * load minimal amounts of data from the input files and flush the output buffers more often.
         */
        unbuffered?: boolean;
        /**
         * output version information and exit.
         */
        version?: boolean;
    }

    /**
     * Abstraction over the `systemctl` utility on a remote system.
     */
    export interface SystemctlOpts {
        /**
         * Corresponds to the COMMAND argument.
         */
        command: enums.tools.SystemctlCommand;
        /**
         * Corresponds to the `--now` option.
         */
        now?: boolean;
        /**
         * Corresponds to the [PATTERN] argument
         */
        pattern?: string;
        /**
         * Corresponds to the [UNIT...] argument.
         */
        unit?: string;
    }

    /**
     * Abstraction over the `tar` utility on a remote system.
     */
    export interface TarOpts {
        /**
         * Corresponds to the [ARCHIVE] argument.
         */
        archive: string;
        /**
         * Corresponds to the `--directory` option.
         */
        directory?: string;
        /**
         * Corresponds to the `--extract` option.
         */
        extract?: boolean;
        /**
         * Corresponds to the [FILE] argument.
         */
        files?: string[];
        /**
         * Corresponds to the `--gzip` option.
         */
        gzip?: boolean;
        /**
         * Whether rm should be run when the resource is created or deleted.
         */
        onDelete?: boolean;
        /**
         * Corresponds to the `--recursive` option.
         */
        recursive?: boolean;
        /**
         * Corresponds to the `--strip-components` option.
         */
        stripComponents?: number;
    }

    /**
     * Abstraction over the `rm` utility on a remote system.
     */
    export interface TeeOpts {
        /**
         * Append to the given FILEs, do not overwrite
         */
        append?: boolean;
        /**
         * Corresponds to the [FILE] argument.
         */
        files: string[];
        /**
         * Ignore interrupt signals.
         */
        ignoreInterrupts?: boolean;
        /**
         * Set behavior on write error.
         */
        outputError?: enums.tools.TeeMode;
        /**
         * Operate in a more appropriate MODE with pipes.
         */
        pipe?: boolean;
        /**
         * Output version information and exit.
         */
        version?: boolean;
    }

    /**
     * Abstraction over the `wget` utility on a remote system.
     */
    export interface WgetOpts {
        /**
         * The  directory prefix is the directory where all other files and subdirectories will be saved to, i.e. the top of the retrieval tree.  The default is . (the current directory).
         */
        directoryPrefix?: string;
        /**
         * When in recursive mode, only HTTPS links are followed.
         */
        httpsOnly?: boolean;
        /**
         * Turn off verbose without being completely quiet (use -q for that), which means that error messages and basic information still get printed.
         */
        noVerbose?: boolean;
        /**
         * The  documents  will  not  be  written  to the appropriate files, but all will be concatenated together and written to file.
         */
        outputDocument?: string;
        /**
         * Turn off Wget's output.
         */
        quiet?: boolean;
        /**
         * Turn on time-stamping.
         */
        timestamping?: boolean;
        /**
         * Corresponds to the [URL...] argument.
         */
        url: string[];
    }

}
