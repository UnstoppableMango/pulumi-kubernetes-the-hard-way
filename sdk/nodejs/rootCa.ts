// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

import * as pulumiTls from "@pulumi/tls";

import {Certificate} from "./index";

export class RootCa extends pulumi.ComponentResource {
    /** @internal */
    public static readonly __pulumiType = 'kubernetes-the-hard-way:index:RootCa';

    /**
     * Returns true if the given object is an instance of RootCa.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is RootCa {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === RootCa.__pulumiType;
    }

    public /*out*/ readonly cert!: pulumi.Output<pulumiTls.SelfSignedCert>;
    public /*out*/ readonly certPem!: pulumi.Output<string>;
    public /*out*/ readonly key!: pulumi.Output<pulumiTls.PrivateKey>;
    public /*out*/ readonly keyPem!: pulumi.Output<string>;

    /**
     * Create a RootCa resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: RootCaArgs, opts?: pulumi.ComponentResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (!opts.id) {
            if ((!args || args.validityPeriodHours === undefined) && !opts.urn) {
                throw new Error("Missing required property 'validityPeriodHours'");
            }
            resourceInputs["algorithm"] = args ? args.algorithm : undefined;
            resourceInputs["dnsNames"] = args ? args.dnsNames : undefined;
            resourceInputs["earlyRenewalHours"] = args ? args.earlyRenewalHours : undefined;
            resourceInputs["ecdsaCurve"] = args ? args.ecdsaCurve : undefined;
            resourceInputs["ipAddresses"] = args ? args.ipAddresses : undefined;
            resourceInputs["rsaBits"] = args ? args.rsaBits : undefined;
            resourceInputs["setAuthorityKeyId"] = args ? args.setAuthorityKeyId : undefined;
            resourceInputs["setSubjectKeyId"] = args ? args.setSubjectKeyId : undefined;
            resourceInputs["subject"] = args ? args.subject : undefined;
            resourceInputs["uris"] = args ? args.uris : undefined;
            resourceInputs["validityPeriodHours"] = args ? args.validityPeriodHours : undefined;
            resourceInputs["cert"] = undefined /*out*/;
            resourceInputs["certPem"] = undefined /*out*/;
            resourceInputs["key"] = undefined /*out*/;
            resourceInputs["keyPem"] = undefined /*out*/;
        } else {
            resourceInputs["cert"] = undefined /*out*/;
            resourceInputs["certPem"] = undefined /*out*/;
            resourceInputs["key"] = undefined /*out*/;
            resourceInputs["keyPem"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(RootCa.__pulumiType, name, resourceInputs, opts, true /*remote*/);
    }

    /**
     * Creates a Certificate configured for the cluster admin.
     */
    getAdminCertificate(args: RootCa.GetAdminCertificateArgs): pulumi.Output<RootCa.GetAdminCertificateResult> {
        return pulumi.runtime.call("kubernetes-the-hard-way:index:RootCa/getAdminCertificate", {
            "__self__": this,
            "algorithm": args.algorithm,
            "allowedUses": args.allowedUses,
            "dnsNames": args.dnsNames,
            "earlyRenewalHours": args.earlyRenewalHours,
            "ecdsaCurve": args.ecdsaCurve,
            "ipAddresses": args.ipAddresses,
            "isCaCertificate": args.isCaCertificate,
            "rsaBits": args.rsaBits,
            "setAuthorityKeyId": args.setAuthorityKeyId,
            "setSubjectKeyId": args.setSubjectKeyId,
            "uris": args.uris,
            "validityPeriodHours": args.validityPeriodHours,
        }, this);
    }

    /**
     * Creates a Certificate configured for the api-server.
     */
    getApiServerCertificate(args: RootCa.GetApiServerCertificateArgs): pulumi.Output<RootCa.GetApiServerCertificateResult> {
        return pulumi.runtime.call("kubernetes-the-hard-way:index:RootCa/getApiServerCertificate", {
            "__self__": this,
            "algorithm": args.algorithm,
            "allowedUses": args.allowedUses,
            "dnsNames": args.dnsNames,
            "earlyRenewalHours": args.earlyRenewalHours,
            "ecdsaCurve": args.ecdsaCurve,
            "ipAddresses": args.ipAddresses,
            "isCaCertificate": args.isCaCertificate,
            "rsaBits": args.rsaBits,
            "setAuthorityKeyId": args.setAuthorityKeyId,
            "setSubjectKeyId": args.setSubjectKeyId,
            "uris": args.uris,
            "validityPeriodHours": args.validityPeriodHours,
        }, this);
    }

    /**
     * Creates a Certificate configured for the controller manager.
     */
    getControllerManagerCertificate(args: RootCa.GetControllerManagerCertificateArgs): pulumi.Output<RootCa.GetControllerManagerCertificateResult> {
        return pulumi.runtime.call("kubernetes-the-hard-way:index:RootCa/getControllerManagerCertificate", {
            "__self__": this,
            "algorithm": args.algorithm,
            "allowedUses": args.allowedUses,
            "dnsNames": args.dnsNames,
            "earlyRenewalHours": args.earlyRenewalHours,
            "ecdsaCurve": args.ecdsaCurve,
            "ipAddresses": args.ipAddresses,
            "isCaCertificate": args.isCaCertificate,
            "rsaBits": args.rsaBits,
            "setAuthorityKeyId": args.setAuthorityKeyId,
            "setSubjectKeyId": args.setSubjectKeyId,
            "uris": args.uris,
            "validityPeriodHours": args.validityPeriodHours,
        }, this);
    }

    /**
     * Creates a Certificate configured for the kube-proxy.
     */
    getKubeProxyCertificate(args: RootCa.GetKubeProxyCertificateArgs): pulumi.Output<RootCa.GetKubeProxyCertificateResult> {
        return pulumi.runtime.call("kubernetes-the-hard-way:index:RootCa/getKubeProxyCertificate", {
            "__self__": this,
            "algorithm": args.algorithm,
            "allowedUses": args.allowedUses,
            "dnsNames": args.dnsNames,
            "earlyRenewalHours": args.earlyRenewalHours,
            "ecdsaCurve": args.ecdsaCurve,
            "ipAddresses": args.ipAddresses,
            "isCaCertificate": args.isCaCertificate,
            "rsaBits": args.rsaBits,
            "setAuthorityKeyId": args.setAuthorityKeyId,
            "setSubjectKeyId": args.setSubjectKeyId,
            "uris": args.uris,
            "validityPeriodHours": args.validityPeriodHours,
        }, this);
    }

    /**
     * Creates a Certificate configured for the kube-scheduler.
     */
    getKubeSchedulerCertificate(args: RootCa.GetKubeSchedulerCertificateArgs): pulumi.Output<RootCa.GetKubeSchedulerCertificateResult> {
        return pulumi.runtime.call("kubernetes-the-hard-way:index:RootCa/getKubeSchedulerCertificate", {
            "__self__": this,
            "algorithm": args.algorithm,
            "allowedUses": args.allowedUses,
            "dnsNames": args.dnsNames,
            "earlyRenewalHours": args.earlyRenewalHours,
            "ecdsaCurve": args.ecdsaCurve,
            "ipAddresses": args.ipAddresses,
            "isCaCertificate": args.isCaCertificate,
            "rsaBits": args.rsaBits,
            "setAuthorityKeyId": args.setAuthorityKeyId,
            "setSubjectKeyId": args.setSubjectKeyId,
            "uris": args.uris,
            "validityPeriodHours": args.validityPeriodHours,
        }, this);
    }

    /**
     * Creates a Certificate configured for a kubelet.
     */
    getKubeletCertificate(args: RootCa.GetKubeletCertificateArgs): pulumi.Output<RootCa.GetKubeletCertificateResult> {
        return pulumi.runtime.call("kubernetes-the-hard-way:index:RootCa/getKubeletCertificate", {
            "__self__": this,
            "algorithm": args.algorithm,
            "allowedUses": args.allowedUses,
            "dnsNames": args.dnsNames,
            "earlyRenewalHours": args.earlyRenewalHours,
            "ecdsaCurve": args.ecdsaCurve,
            "ipAddresses": args.ipAddresses,
            "isCaCertificate": args.isCaCertificate,
            "rsaBits": args.rsaBits,
            "setAuthorityKeyId": args.setAuthorityKeyId,
            "setSubjectKeyId": args.setSubjectKeyId,
            "uris": args.uris,
            "validityPeriodHours": args.validityPeriodHours,
        }, this);
    }

    /**
     * Creates a Certificate configured for the kube-scheduler.
     */
    getServiceAccountsCertificate(args: RootCa.GetServiceAccountsCertificateArgs): pulumi.Output<RootCa.GetServiceAccountsCertificateResult> {
        return pulumi.runtime.call("kubernetes-the-hard-way:index:RootCa/getServiceAccountsCertificate", {
            "__self__": this,
            "algorithm": args.algorithm,
            "allowedUses": args.allowedUses,
            "dnsNames": args.dnsNames,
            "earlyRenewalHours": args.earlyRenewalHours,
            "ecdsaCurve": args.ecdsaCurve,
            "ipAddresses": args.ipAddresses,
            "isCaCertificate": args.isCaCertificate,
            "rsaBits": args.rsaBits,
            "setAuthorityKeyId": args.setAuthorityKeyId,
            "setSubjectKeyId": args.setSubjectKeyId,
            "uris": args.uris,
            "validityPeriodHours": args.validityPeriodHours,
        }, this);
    }
}

/**
 * The set of arguments for constructing a RootCa resource.
 */
export interface RootCaArgs {
    /**
     * Name of the algorithm to use when generating the private key.
     */
    algorithm?: pulumi.Input<string>;
    /**
     * List of DNS names for which a certificate is being requested.
     */
    dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * TODO
     */
    earlyRenewalHours?: pulumi.Input<number>;
    /**
     * When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
     */
    ecdsaCurve?: pulumi.Input<string>;
    /**
     * List of IP addresses for which a certificate is being requested.
     */
    ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
     */
    rsaBits?: pulumi.Input<number>;
    /**
     * Should the generated certificate include an authority key identifier.
     */
    setAuthorityKeyId?: pulumi.Input<boolean>;
    /**
     * Should the generated certificate include a subject key identifier.
     */
    setSubjectKeyId?: pulumi.Input<boolean>;
    subject?: pulumi.Input<pulumiTls.types.input.SelfSignedCertSubject>;
    /**
     * List of URIs for which a certificate is being requested.
     */
    uris?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Number of hours, after initial issuing, that the certificate will remain valid.
     */
    validityPeriodHours: pulumi.Input<number>;
}

export namespace RootCa {
    /**
     * The set of arguments for the RootCa.getAdminCertificate method.
     */
    export interface GetAdminCertificateArgs {
        /**
         * Name of the algorithm to use when generating the private key.
         */
        algorithm?: pulumi.Input<string>;
        allowedUses: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of DNS names for which a certificate is being requested.
         */
        dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * TODO
         */
        earlyRenewalHours?: pulumi.Input<number>;
        /**
         * When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
         */
        ecdsaCurve?: pulumi.Input<string>;
        /**
         * List of IP addresses for which a certificate is being requested.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        isCaCertificate?: pulumi.Input<boolean>;
        /**
         * When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
         */
        rsaBits?: pulumi.Input<number>;
        /**
         * Should the generated certificate include an authority key identifier.
         */
        setAuthorityKeyId?: pulumi.Input<boolean>;
        /**
         * Should the generated certificate include a subject key identifier.
         */
        setSubjectKeyId?: pulumi.Input<boolean>;
        /**
         * List of URIs for which a certificate is being requested.
         */
        uris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Number of hours, after initial issuing, that the certificate will remain valid.
         */
        validityPeriodHours: pulumi.Input<number>;
    }

    /**
     * The results of the RootCa.getAdminCertificate method.
     */
    export interface GetAdminCertificateResult {
        readonly cert: Certificate;
    }

    /**
     * The set of arguments for the RootCa.getApiServerCertificate method.
     */
    export interface GetApiServerCertificateArgs {
        /**
         * Name of the algorithm to use when generating the private key.
         */
        algorithm?: pulumi.Input<string>;
        allowedUses: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of DNS names for which a certificate is being requested.
         */
        dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * TODO
         */
        earlyRenewalHours?: pulumi.Input<number>;
        /**
         * When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
         */
        ecdsaCurve?: pulumi.Input<string>;
        /**
         * List of IP addresses for which a certificate is being requested.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        isCaCertificate?: pulumi.Input<boolean>;
        /**
         * When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
         */
        rsaBits?: pulumi.Input<number>;
        /**
         * Should the generated certificate include an authority key identifier.
         */
        setAuthorityKeyId?: pulumi.Input<boolean>;
        /**
         * Should the generated certificate include a subject key identifier.
         */
        setSubjectKeyId?: pulumi.Input<boolean>;
        /**
         * List of URIs for which a certificate is being requested.
         */
        uris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Number of hours, after initial issuing, that the certificate will remain valid.
         */
        validityPeriodHours: pulumi.Input<number>;
    }

    /**
     * The results of the RootCa.getApiServerCertificate method.
     */
    export interface GetApiServerCertificateResult {
        readonly cert: Certificate;
    }

    /**
     * The set of arguments for the RootCa.getControllerManagerCertificate method.
     */
    export interface GetControllerManagerCertificateArgs {
        /**
         * Name of the algorithm to use when generating the private key.
         */
        algorithm?: pulumi.Input<string>;
        allowedUses: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of DNS names for which a certificate is being requested.
         */
        dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * TODO
         */
        earlyRenewalHours?: pulumi.Input<number>;
        /**
         * When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
         */
        ecdsaCurve?: pulumi.Input<string>;
        /**
         * List of IP addresses for which a certificate is being requested.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        isCaCertificate?: pulumi.Input<boolean>;
        /**
         * When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
         */
        rsaBits?: pulumi.Input<number>;
        /**
         * Should the generated certificate include an authority key identifier.
         */
        setAuthorityKeyId?: pulumi.Input<boolean>;
        /**
         * Should the generated certificate include a subject key identifier.
         */
        setSubjectKeyId?: pulumi.Input<boolean>;
        /**
         * List of URIs for which a certificate is being requested.
         */
        uris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Number of hours, after initial issuing, that the certificate will remain valid.
         */
        validityPeriodHours: pulumi.Input<number>;
    }

    /**
     * The results of the RootCa.getControllerManagerCertificate method.
     */
    export interface GetControllerManagerCertificateResult {
        readonly cert: Certificate;
    }

    /**
     * The set of arguments for the RootCa.getKubeProxyCertificate method.
     */
    export interface GetKubeProxyCertificateArgs {
        /**
         * Name of the algorithm to use when generating the private key.
         */
        algorithm?: pulumi.Input<string>;
        allowedUses: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of DNS names for which a certificate is being requested.
         */
        dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * TODO
         */
        earlyRenewalHours?: pulumi.Input<number>;
        /**
         * When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
         */
        ecdsaCurve?: pulumi.Input<string>;
        /**
         * List of IP addresses for which a certificate is being requested.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        isCaCertificate?: pulumi.Input<boolean>;
        /**
         * When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
         */
        rsaBits?: pulumi.Input<number>;
        /**
         * Should the generated certificate include an authority key identifier.
         */
        setAuthorityKeyId?: pulumi.Input<boolean>;
        /**
         * Should the generated certificate include a subject key identifier.
         */
        setSubjectKeyId?: pulumi.Input<boolean>;
        /**
         * List of URIs for which a certificate is being requested.
         */
        uris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Number of hours, after initial issuing, that the certificate will remain valid.
         */
        validityPeriodHours: pulumi.Input<number>;
    }

    /**
     * The results of the RootCa.getKubeProxyCertificate method.
     */
    export interface GetKubeProxyCertificateResult {
        readonly cert: Certificate;
    }

    /**
     * The set of arguments for the RootCa.getKubeSchedulerCertificate method.
     */
    export interface GetKubeSchedulerCertificateArgs {
        /**
         * Name of the algorithm to use when generating the private key.
         */
        algorithm?: pulumi.Input<string>;
        allowedUses: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of DNS names for which a certificate is being requested.
         */
        dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * TODO
         */
        earlyRenewalHours?: pulumi.Input<number>;
        /**
         * When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
         */
        ecdsaCurve?: pulumi.Input<string>;
        /**
         * List of IP addresses for which a certificate is being requested.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        isCaCertificate?: pulumi.Input<boolean>;
        /**
         * When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
         */
        rsaBits?: pulumi.Input<number>;
        /**
         * Should the generated certificate include an authority key identifier.
         */
        setAuthorityKeyId?: pulumi.Input<boolean>;
        /**
         * Should the generated certificate include a subject key identifier.
         */
        setSubjectKeyId?: pulumi.Input<boolean>;
        /**
         * List of URIs for which a certificate is being requested.
         */
        uris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Number of hours, after initial issuing, that the certificate will remain valid.
         */
        validityPeriodHours: pulumi.Input<number>;
    }

    /**
     * The results of the RootCa.getKubeSchedulerCertificate method.
     */
    export interface GetKubeSchedulerCertificateResult {
        readonly cert: Certificate;
    }

    /**
     * The set of arguments for the RootCa.getKubeletCertificate method.
     */
    export interface GetKubeletCertificateArgs {
        /**
         * Name of the algorithm to use when generating the private key.
         */
        algorithm?: pulumi.Input<string>;
        allowedUses: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of DNS names for which a certificate is being requested.
         */
        dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * TODO
         */
        earlyRenewalHours?: pulumi.Input<number>;
        /**
         * When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
         */
        ecdsaCurve?: pulumi.Input<string>;
        /**
         * List of IP addresses for which a certificate is being requested.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        isCaCertificate?: pulumi.Input<boolean>;
        /**
         * When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
         */
        rsaBits?: pulumi.Input<number>;
        /**
         * Should the generated certificate include an authority key identifier.
         */
        setAuthorityKeyId?: pulumi.Input<boolean>;
        /**
         * Should the generated certificate include a subject key identifier.
         */
        setSubjectKeyId?: pulumi.Input<boolean>;
        /**
         * List of URIs for which a certificate is being requested.
         */
        uris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Number of hours, after initial issuing, that the certificate will remain valid.
         */
        validityPeriodHours: pulumi.Input<number>;
    }

    /**
     * The results of the RootCa.getKubeletCertificate method.
     */
    export interface GetKubeletCertificateResult {
        readonly cert: Certificate;
    }

    /**
     * The set of arguments for the RootCa.getServiceAccountsCertificate method.
     */
    export interface GetServiceAccountsCertificateArgs {
        /**
         * Name of the algorithm to use when generating the private key.
         */
        algorithm?: pulumi.Input<string>;
        allowedUses: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of DNS names for which a certificate is being requested.
         */
        dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * TODO
         */
        earlyRenewalHours?: pulumi.Input<number>;
        /**
         * When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
         */
        ecdsaCurve?: pulumi.Input<string>;
        /**
         * List of IP addresses for which a certificate is being requested.
         */
        ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        isCaCertificate?: pulumi.Input<boolean>;
        /**
         * When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
         */
        rsaBits?: pulumi.Input<number>;
        /**
         * Should the generated certificate include an authority key identifier.
         */
        setAuthorityKeyId?: pulumi.Input<boolean>;
        /**
         * Should the generated certificate include a subject key identifier.
         */
        setSubjectKeyId?: pulumi.Input<boolean>;
        /**
         * List of URIs for which a certificate is being requested.
         */
        uris?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Number of hours, after initial issuing, that the certificate will remain valid.
         */
        validityPeriodHours: pulumi.Input<number>;
    }

    /**
     * The results of the RootCa.getServiceAccountsCertificate method.
     */
    export interface GetServiceAccountsCertificateResult {
        readonly cert: Certificate;
    }

}
