// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as enums from "./types/enums";
import * as utilities from "./utilities";

import {Certificate, RootCa} from "./index";

/**
 * Creates a Certificate configured for the current authority.
 */
export function newCertificate(args: NewCertificateArgs, opts?: pulumi.InvokeOptions): Promise<NewCertificateResult> {

    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("kubernetes-the-hard-way:index:newCertificate", {
        "algorithm": args.algorithm,
        "allowedUses": args.allowedUses,
        "ca": args.ca,
        "dnsNames": args.dnsNames,
        "earlyRenewalHours": args.earlyRenewalHours,
        "ecdsaCurve": args.ecdsaCurve,
        "ipAddresses": args.ipAddresses,
        "isCaCertificate": args.isCaCertificate,
        "name": args.name,
        "opts": args.opts,
        "rsaBits": args.rsaBits,
        "setAuthorityKeyId": args.setAuthorityKeyId,
        "setSubjectKeyId": args.setSubjectKeyId,
        "subject": args.subject,
        "uris": args.uris,
        "validityPeriodHours": args.validityPeriodHours,
    }, opts);
}

export interface NewCertificateArgs {
    /**
     * Name of the algorithm to use when generating the private key.
     */
    algorithm: enums.Algorithm;
    allowedUses: enums.AllowedUsage[];
    /**
     * The certificate authority to issue the certificate.
     */
    ca: RootCa;
    /**
     * List of DNS names for which a certificate is being requested.
     */
    dnsNames?: string[];
    /**
     * TODO
     */
    earlyRenewalHours?: number;
    /**
     * When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
     */
    ecdsaCurve?: enums.EcdsaCurve;
    /**
     * List of IP addresses for which a certificate is being requested.
     */
    ipAddresses?: string[];
    isCaCertificate?: boolean;
    name: string;
    opts?: inputs.ResourceOptions;
    /**
     * When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
     */
    rsaBits?: number;
    /**
     * Should the generated certificate include an authority key identifier.
     */
    setAuthorityKeyId?: boolean;
    /**
     * Should the generated certificate include a subject key identifier.
     */
    setSubjectKeyId?: boolean;
    subject?: inputs.CertRequestSubject;
    /**
     * List of URIs for which a certificate is being requested.
     */
    uris?: string[];
    /**
     * Number of hours, after initial issuing, that the certificate will remain valid.
     */
    validityPeriodHours: number;
}

export interface NewCertificateResult {
    readonly result: Certificate;
}
/**
 * Creates a Certificate configured for the current authority.
 */
export function newCertificateOutput(args: NewCertificateOutputArgs, opts?: pulumi.InvokeOptions): pulumi.Output<NewCertificateResult> {
    return pulumi.output(args).apply((a: any) => newCertificate(a, opts))
}

export interface NewCertificateOutputArgs {
    /**
     * Name of the algorithm to use when generating the private key.
     */
    algorithm: pulumi.Input<enums.Algorithm>;
    allowedUses: pulumi.Input<pulumi.Input<enums.AllowedUsage>[]>;
    /**
     * The certificate authority to issue the certificate.
     */
    ca: pulumi.Input<RootCa>;
    /**
     * List of DNS names for which a certificate is being requested.
     */
    dnsNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * TODO
     */
    earlyRenewalHours?: pulumi.Input<number>;
    /**
     * When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
     */
    ecdsaCurve?: pulumi.Input<enums.EcdsaCurve>;
    /**
     * List of IP addresses for which a certificate is being requested.
     */
    ipAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    isCaCertificate?: pulumi.Input<boolean>;
    name: string;
    opts?: inputs.ResourceOptionsArgs;
    /**
     * When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
     */
    rsaBits?: pulumi.Input<number>;
    /**
     * Should the generated certificate include an authority key identifier.
     */
    setAuthorityKeyId?: pulumi.Input<boolean>;
    /**
     * Should the generated certificate include a subject key identifier.
     */
    setSubjectKeyId?: pulumi.Input<boolean>;
    subject?: pulumi.Input<inputs.CertRequestSubjectArgs>;
    /**
     * List of URIs for which a certificate is being requested.
     */
    uris?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Number of hours, after initial issuing, that the certificate will remain valid.
     */
    validityPeriodHours: pulumi.Input<number>;
}
