// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package tls

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-random/sdk/v4/go/random"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/unstoppablemango/pulumi-kubernetes-the-hard-way/internal"
)

// A cluster encryption key.
type EncryptionKey struct {
	pulumi.ResourceState

	// The number of bytes requested. The minimum value for length is 1.
	Bytes pulumi.IntOutput `pulumi:"bytes"`
	// The generated `v1/EncryptionConfig`.
	Config pulumi.StringOutput `pulumi:"config"`
	// The generated random key.
	Key random.RandomBytesOutput `pulumi:"key"`
}

// NewEncryptionKey registers a new resource with the given unique name, arguments, and options.
func NewEncryptionKey(ctx *pulumi.Context,
	name string, args *EncryptionKeyArgs, opts ...pulumi.ResourceOption) (*EncryptionKey, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Bytes == nil {
		return nil, errors.New("invalid value for required argument 'Bytes'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource EncryptionKey
	err := ctx.RegisterRemoteComponentResource("kubernetes-the-hard-way:tls:EncryptionKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type encryptionKeyArgs struct {
	// The number of bytes requested. The minimum value for length is 1.
	Bytes int `pulumi:"bytes"`
}

// The set of arguments for constructing a EncryptionKey resource.
type EncryptionKeyArgs struct {
	// The number of bytes requested. The minimum value for length is 1.
	Bytes pulumi.IntInput
}

func (EncryptionKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*encryptionKeyArgs)(nil)).Elem()
}

type EncryptionKeyInput interface {
	pulumi.Input

	ToEncryptionKeyOutput() EncryptionKeyOutput
	ToEncryptionKeyOutputWithContext(ctx context.Context) EncryptionKeyOutput
}

func (*EncryptionKey) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionKey)(nil)).Elem()
}

func (i *EncryptionKey) ToEncryptionKeyOutput() EncryptionKeyOutput {
	return i.ToEncryptionKeyOutputWithContext(context.Background())
}

func (i *EncryptionKey) ToEncryptionKeyOutputWithContext(ctx context.Context) EncryptionKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionKeyOutput)
}

// EncryptionKeyArrayInput is an input type that accepts EncryptionKeyArray and EncryptionKeyArrayOutput values.
// You can construct a concrete instance of `EncryptionKeyArrayInput` via:
//
//	EncryptionKeyArray{ EncryptionKeyArgs{...} }
type EncryptionKeyArrayInput interface {
	pulumi.Input

	ToEncryptionKeyArrayOutput() EncryptionKeyArrayOutput
	ToEncryptionKeyArrayOutputWithContext(context.Context) EncryptionKeyArrayOutput
}

type EncryptionKeyArray []EncryptionKeyInput

func (EncryptionKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*EncryptionKey)(nil)).Elem()
}

func (i EncryptionKeyArray) ToEncryptionKeyArrayOutput() EncryptionKeyArrayOutput {
	return i.ToEncryptionKeyArrayOutputWithContext(context.Background())
}

func (i EncryptionKeyArray) ToEncryptionKeyArrayOutputWithContext(ctx context.Context) EncryptionKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionKeyArrayOutput)
}

// EncryptionKeyMapInput is an input type that accepts EncryptionKeyMap and EncryptionKeyMapOutput values.
// You can construct a concrete instance of `EncryptionKeyMapInput` via:
//
//	EncryptionKeyMap{ "key": EncryptionKeyArgs{...} }
type EncryptionKeyMapInput interface {
	pulumi.Input

	ToEncryptionKeyMapOutput() EncryptionKeyMapOutput
	ToEncryptionKeyMapOutputWithContext(context.Context) EncryptionKeyMapOutput
}

type EncryptionKeyMap map[string]EncryptionKeyInput

func (EncryptionKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*EncryptionKey)(nil)).Elem()
}

func (i EncryptionKeyMap) ToEncryptionKeyMapOutput() EncryptionKeyMapOutput {
	return i.ToEncryptionKeyMapOutputWithContext(context.Background())
}

func (i EncryptionKeyMap) ToEncryptionKeyMapOutputWithContext(ctx context.Context) EncryptionKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionKeyMapOutput)
}

type EncryptionKeyOutput struct{ *pulumi.OutputState }

func (EncryptionKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionKey)(nil)).Elem()
}

func (o EncryptionKeyOutput) ToEncryptionKeyOutput() EncryptionKeyOutput {
	return o
}

func (o EncryptionKeyOutput) ToEncryptionKeyOutputWithContext(ctx context.Context) EncryptionKeyOutput {
	return o
}

// The number of bytes requested. The minimum value for length is 1.
func (o EncryptionKeyOutput) Bytes() pulumi.IntOutput {
	return o.ApplyT(func(v *EncryptionKey) pulumi.IntOutput { return v.Bytes }).(pulumi.IntOutput)
}

// The generated `v1/EncryptionConfig`.
func (o EncryptionKeyOutput) Config() pulumi.StringOutput {
	return o.ApplyT(func(v *EncryptionKey) pulumi.StringOutput { return v.Config }).(pulumi.StringOutput)
}

// The generated random key.
func (o EncryptionKeyOutput) Key() random.RandomBytesOutput {
	return o.ApplyT(func(v *EncryptionKey) random.RandomBytesOutput { return v.Key }).(random.RandomBytesOutput)
}

type EncryptionKeyArrayOutput struct{ *pulumi.OutputState }

func (EncryptionKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*EncryptionKey)(nil)).Elem()
}

func (o EncryptionKeyArrayOutput) ToEncryptionKeyArrayOutput() EncryptionKeyArrayOutput {
	return o
}

func (o EncryptionKeyArrayOutput) ToEncryptionKeyArrayOutputWithContext(ctx context.Context) EncryptionKeyArrayOutput {
	return o
}

func (o EncryptionKeyArrayOutput) Index(i pulumi.IntInput) EncryptionKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *EncryptionKey {
		return vs[0].([]*EncryptionKey)[vs[1].(int)]
	}).(EncryptionKeyOutput)
}

type EncryptionKeyMapOutput struct{ *pulumi.OutputState }

func (EncryptionKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*EncryptionKey)(nil)).Elem()
}

func (o EncryptionKeyMapOutput) ToEncryptionKeyMapOutput() EncryptionKeyMapOutput {
	return o
}

func (o EncryptionKeyMapOutput) ToEncryptionKeyMapOutputWithContext(ctx context.Context) EncryptionKeyMapOutput {
	return o
}

func (o EncryptionKeyMapOutput) MapIndex(k pulumi.StringInput) EncryptionKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *EncryptionKey {
		return vs[0].(map[string]*EncryptionKey)[vs[1].(string)]
	}).(EncryptionKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*EncryptionKeyInput)(nil)).Elem(), &EncryptionKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*EncryptionKeyArrayInput)(nil)).Elem(), EncryptionKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*EncryptionKeyMapInput)(nil)).Elem(), EncryptionKeyMap{})
	pulumi.RegisterOutputType(EncryptionKeyOutput{})
	pulumi.RegisterOutputType(EncryptionKeyArrayOutput{})
	pulumi.RegisterOutputType(EncryptionKeyMapOutput{})
}
