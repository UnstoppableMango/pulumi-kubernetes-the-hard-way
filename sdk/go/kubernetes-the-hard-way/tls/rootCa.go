// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package tls

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-tls/sdk/v5/go/tls"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/unstoppablemango/pulumi-kubernetes-the-hard-way/sdk/go/kubernetes-the-hard-way"
	"github.com/unstoppablemango/pulumi-kubernetes-the-hard-way/sdk/go/kubernetes-the-hard-way/internal"
	"github.com/unstoppablemango/pulumi-kubernetes-the-hard-way/sdk/go/kubernetes-the-hard-way/remote"
)

type RootCa struct {
	pulumi.ResourceState

	AllowedUses   AllowedUsageArrayOutput  `pulumi:"allowedUses"`
	Cert          tls.SelfSignedCertOutput `pulumi:"cert"`
	CertPem       pulumi.StringOutput      `pulumi:"certPem"`
	Key           tls.PrivateKeyOutput     `pulumi:"key"`
	PrivateKeyPem pulumi.StringOutput      `pulumi:"privateKeyPem"`
	PublicKeyPem  pulumi.StringOutput      `pulumi:"publicKeyPem"`
}

// NewRootCa registers a new resource with the given unique name, arguments, and options.
func NewRootCa(ctx *pulumi.Context,
	name string, args *RootCaArgs, opts ...pulumi.ResourceOption) (*RootCa, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ValidityPeriodHours == nil {
		return nil, errors.New("invalid value for required argument 'ValidityPeriodHours'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RootCa
	err := ctx.RegisterRemoteComponentResource("kubernetes-the-hard-way:tls:RootCa", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type rootCaArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm *Algorithm `pulumi:"algorithm"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *EcdsaCurve `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses []string `pulumi:"ipAddresses"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool                      `pulumi:"setSubjectKeyId"`
	Subject         *tls.SelfSignedCertSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for constructing a RootCa resource.
type RootCaArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm AlgorithmPtrInput
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve EcdsaCurvePtrInput
	// List of IP addresses for which a certificate is being requested.
	IpAddresses pulumi.StringArrayInput
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput
	Subject         tls.SelfSignedCertSubjectPtrInput
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput
}

func (RootCaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaArgs)(nil)).Elem()
}

// Creates a RemoteFile resource representing the copy operation.
func (r *RootCa) InstallCert(ctx *pulumi.Context, args *RootCaInstallCertArgs) (remote.FileOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:tls:RootCa/installCert", args, rootCaInstallCertResultOutput{}, r)
	if err != nil {
		return remote.FileOutput{}, err
	}
	return out.(rootCaInstallCertResultOutput).Result(), nil
}

type rootCaInstallCertArgs struct {
	// The connection details.
	Connection kubernetesthehardway.Connection       `pulumi:"connection"`
	Name       string                                `pulumi:"name"`
	Options    *kubernetesthehardway.ResourceOptions `pulumi:"options"`
	// The path to install to.
	Path *string `pulumi:"path"`
}

// The set of arguments for the InstallCert method of the RootCa resource.
type RootCaInstallCertArgs struct {
	// The connection details.
	Connection kubernetesthehardway.ConnectionInput
	Name       string
	Options    *kubernetesthehardway.ResourceOptionsArgs
	// The path to install to.
	Path pulumi.StringPtrInput
}

func (RootCaInstallCertArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaInstallCertArgs)(nil)).Elem()
}

type rootCaInstallCertResult struct {
	Result *remote.File `pulumi:"result"`
}

type rootCaInstallCertResultOutput struct{ *pulumi.OutputState }

func (rootCaInstallCertResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaInstallCertResult)(nil)).Elem()
}

func (o rootCaInstallCertResultOutput) Result() remote.FileOutput {
	return o.ApplyT(func(v rootCaInstallCertResult) *remote.File { return v.Result }).(remote.FileOutput)
}

// Creates a RemoteFile resource representing the copy operation.
func (r *RootCa) InstallKey(ctx *pulumi.Context, args *RootCaInstallKeyArgs) (remote.FileOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:tls:RootCa/installKey", args, rootCaInstallKeyResultOutput{}, r)
	if err != nil {
		return remote.FileOutput{}, err
	}
	return out.(rootCaInstallKeyResultOutput).Result(), nil
}

type rootCaInstallKeyArgs struct {
	// The connection details.
	Connection kubernetesthehardway.Connection       `pulumi:"connection"`
	Name       string                                `pulumi:"name"`
	Options    *kubernetesthehardway.ResourceOptions `pulumi:"options"`
	// The path to install to.
	Path *string `pulumi:"path"`
}

// The set of arguments for the InstallKey method of the RootCa resource.
type RootCaInstallKeyArgs struct {
	// The connection details.
	Connection kubernetesthehardway.ConnectionInput
	Name       string
	Options    *kubernetesthehardway.ResourceOptionsArgs
	// The path to install to.
	Path pulumi.StringPtrInput
}

func (RootCaInstallKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaInstallKeyArgs)(nil)).Elem()
}

type rootCaInstallKeyResult struct {
	Result *remote.File `pulumi:"result"`
}

type rootCaInstallKeyResultOutput struct{ *pulumi.OutputState }

func (rootCaInstallKeyResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaInstallKeyResult)(nil)).Elem()
}

func (o rootCaInstallKeyResultOutput) Result() remote.FileOutput {
	return o.ApplyT(func(v rootCaInstallKeyResult) *remote.File { return v.Result }).(remote.FileOutput)
}

// Creates a Certificate configured for the current authority.
func (r *RootCa) NewCertificate(ctx *pulumi.Context, args *RootCaNewCertificateArgs) (CertificateOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:tls:RootCa/newCertificate", args, rootCaNewCertificateResultOutput{}, r)
	if err != nil {
		return CertificateOutput{}, err
	}
	return out.(rootCaNewCertificateResultOutput).Result(), nil
}

type rootCaNewCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   Algorithm      `pulumi:"algorithm"`
	AllowedUses []AllowedUsage `pulumi:"allowedUses"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *EcdsaCurve `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     []string                              `pulumi:"ipAddresses"`
	IsCaCertificate *bool                                 `pulumi:"isCaCertificate"`
	Name            string                                `pulumi:"name"`
	Options         *kubernetesthehardway.ResourceOptions `pulumi:"options"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool                                    `pulumi:"setSubjectKeyId"`
	Subject         *kubernetesthehardway.CertRequestSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for the NewCertificate method of the RootCa resource.
type RootCaNewCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   AlgorithmInput
	AllowedUses AllowedUsageArrayInput
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve EcdsaCurvePtrInput
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     pulumi.StringArrayInput
	IsCaCertificate pulumi.BoolPtrInput
	Name            string
	Options         *kubernetesthehardway.ResourceOptionsArgs
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput
	Subject         kubernetesthehardway.CertRequestSubjectPtrInput
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput
}

func (RootCaNewCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaNewCertificateArgs)(nil)).Elem()
}

type rootCaNewCertificateResult struct {
	// The issued certificate.
	Result *Certificate `pulumi:"result"`
}

type rootCaNewCertificateResultOutput struct{ *pulumi.OutputState }

func (rootCaNewCertificateResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaNewCertificateResult)(nil)).Elem()
}

// The issued certificate.
func (o rootCaNewCertificateResultOutput) Result() CertificateOutput {
	return o.ApplyT(func(v rootCaNewCertificateResult) *Certificate { return v.Result }).(CertificateOutput)
}

type RootCaInput interface {
	pulumi.Input

	ToRootCaOutput() RootCaOutput
	ToRootCaOutputWithContext(ctx context.Context) RootCaOutput
}

func (*RootCa) ElementType() reflect.Type {
	return reflect.TypeOf((**RootCa)(nil)).Elem()
}

func (i *RootCa) ToRootCaOutput() RootCaOutput {
	return i.ToRootCaOutputWithContext(context.Background())
}

func (i *RootCa) ToRootCaOutputWithContext(ctx context.Context) RootCaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RootCaOutput)
}

// RootCaArrayInput is an input type that accepts RootCaArray and RootCaArrayOutput values.
// You can construct a concrete instance of `RootCaArrayInput` via:
//
//	RootCaArray{ RootCaArgs{...} }
type RootCaArrayInput interface {
	pulumi.Input

	ToRootCaArrayOutput() RootCaArrayOutput
	ToRootCaArrayOutputWithContext(context.Context) RootCaArrayOutput
}

type RootCaArray []RootCaInput

func (RootCaArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RootCa)(nil)).Elem()
}

func (i RootCaArray) ToRootCaArrayOutput() RootCaArrayOutput {
	return i.ToRootCaArrayOutputWithContext(context.Background())
}

func (i RootCaArray) ToRootCaArrayOutputWithContext(ctx context.Context) RootCaArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RootCaArrayOutput)
}

// RootCaMapInput is an input type that accepts RootCaMap and RootCaMapOutput values.
// You can construct a concrete instance of `RootCaMapInput` via:
//
//	RootCaMap{ "key": RootCaArgs{...} }
type RootCaMapInput interface {
	pulumi.Input

	ToRootCaMapOutput() RootCaMapOutput
	ToRootCaMapOutputWithContext(context.Context) RootCaMapOutput
}

type RootCaMap map[string]RootCaInput

func (RootCaMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RootCa)(nil)).Elem()
}

func (i RootCaMap) ToRootCaMapOutput() RootCaMapOutput {
	return i.ToRootCaMapOutputWithContext(context.Background())
}

func (i RootCaMap) ToRootCaMapOutputWithContext(ctx context.Context) RootCaMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RootCaMapOutput)
}

type RootCaOutput struct{ *pulumi.OutputState }

func (RootCaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RootCa)(nil)).Elem()
}

func (o RootCaOutput) ToRootCaOutput() RootCaOutput {
	return o
}

func (o RootCaOutput) ToRootCaOutputWithContext(ctx context.Context) RootCaOutput {
	return o
}

func (o RootCaOutput) AllowedUses() AllowedUsageArrayOutput {
	return o.ApplyT(func(v *RootCa) AllowedUsageArrayOutput { return v.AllowedUses }).(AllowedUsageArrayOutput)
}

func (o RootCaOutput) Cert() tls.SelfSignedCertOutput {
	return o.ApplyT(func(v *RootCa) tls.SelfSignedCertOutput { return v.Cert }).(tls.SelfSignedCertOutput)
}

func (o RootCaOutput) CertPem() pulumi.StringOutput {
	return o.ApplyT(func(v *RootCa) pulumi.StringOutput { return v.CertPem }).(pulumi.StringOutput)
}

func (o RootCaOutput) Key() tls.PrivateKeyOutput {
	return o.ApplyT(func(v *RootCa) tls.PrivateKeyOutput { return v.Key }).(tls.PrivateKeyOutput)
}

func (o RootCaOutput) PrivateKeyPem() pulumi.StringOutput {
	return o.ApplyT(func(v *RootCa) pulumi.StringOutput { return v.PrivateKeyPem }).(pulumi.StringOutput)
}

func (o RootCaOutput) PublicKeyPem() pulumi.StringOutput {
	return o.ApplyT(func(v *RootCa) pulumi.StringOutput { return v.PublicKeyPem }).(pulumi.StringOutput)
}

type RootCaArrayOutput struct{ *pulumi.OutputState }

func (RootCaArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RootCa)(nil)).Elem()
}

func (o RootCaArrayOutput) ToRootCaArrayOutput() RootCaArrayOutput {
	return o
}

func (o RootCaArrayOutput) ToRootCaArrayOutputWithContext(ctx context.Context) RootCaArrayOutput {
	return o
}

func (o RootCaArrayOutput) Index(i pulumi.IntInput) RootCaOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RootCa {
		return vs[0].([]*RootCa)[vs[1].(int)]
	}).(RootCaOutput)
}

type RootCaMapOutput struct{ *pulumi.OutputState }

func (RootCaMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RootCa)(nil)).Elem()
}

func (o RootCaMapOutput) ToRootCaMapOutput() RootCaMapOutput {
	return o
}

func (o RootCaMapOutput) ToRootCaMapOutputWithContext(ctx context.Context) RootCaMapOutput {
	return o
}

func (o RootCaMapOutput) MapIndex(k pulumi.StringInput) RootCaOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RootCa {
		return vs[0].(map[string]*RootCa)[vs[1].(string)]
	}).(RootCaOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RootCaInput)(nil)).Elem(), &RootCa{})
	pulumi.RegisterInputType(reflect.TypeOf((*RootCaArrayInput)(nil)).Elem(), RootCaArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RootCaMapInput)(nil)).Elem(), RootCaMap{})
	pulumi.RegisterOutputType(RootCaOutput{})
	pulumi.RegisterOutputType(rootCaInstallCertResultOutput{})
	pulumi.RegisterOutputType(rootCaInstallKeyResultOutput{})
	pulumi.RegisterOutputType(rootCaNewCertificateResultOutput{})
	pulumi.RegisterOutputType(RootCaArrayOutput{})
	pulumi.RegisterOutputType(RootCaMapOutput{})
}
