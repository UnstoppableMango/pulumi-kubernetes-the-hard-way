// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kubernetesthehardway

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-command/sdk/go/command/remote"
	"github.com/pulumi/pulumi-tls/sdk/v5/go/tls"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/unstoppablemango/pulumi-kubernetes-the-hard-way/sdk/go/kubernetes-the-hard-way/internal"
)

type RootCa struct {
	pulumi.ResourceState

	Cert    tls.SelfSignedCertOutput `pulumi:"cert"`
	CertPem pulumi.StringOutput      `pulumi:"certPem"`
	Key     tls.PrivateKeyOutput     `pulumi:"key"`
	KeyPem  pulumi.StringOutput      `pulumi:"keyPem"`
}

// NewRootCa registers a new resource with the given unique name, arguments, and options.
func NewRootCa(ctx *pulumi.Context,
	name string, args *RootCaArgs, opts ...pulumi.ResourceOption) (*RootCa, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ValidityPeriodHours == nil {
		return nil, errors.New("invalid value for required argument 'ValidityPeriodHours'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RootCa
	err := ctx.RegisterRemoteComponentResource("kubernetes-the-hard-way:index:RootCa", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type rootCaArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm *string `pulumi:"algorithm"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *string `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses []string `pulumi:"ipAddresses"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool                      `pulumi:"setSubjectKeyId"`
	Subject         *tls.SelfSignedCertSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for constructing a RootCa resource.
type RootCaArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm pulumi.StringPtrInput
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve pulumi.StringPtrInput
	// List of IP addresses for which a certificate is being requested.
	IpAddresses pulumi.StringArrayInput
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput
	Subject         tls.SelfSignedCertSubjectPtrInput
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput
}

func (RootCaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaArgs)(nil)).Elem()
}

// Creates a Certificate configured for the cluster admin.
func (r *RootCa) GetAdminCertificate(ctx *pulumi.Context, args *RootCaGetAdminCertificateArgs) (RootCaGetAdminCertificateResultOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:index:RootCa/getAdminCertificate", args, RootCaGetAdminCertificateResultOutput{}, r)
	if err != nil {
		return RootCaGetAdminCertificateResultOutput{}, err
	}
	return out.(RootCaGetAdminCertificateResultOutput), nil
}

type rootCaGetAdminCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   *string  `pulumi:"algorithm"`
	AllowedUses []string `pulumi:"allowedUses"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *string `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     []string `pulumi:"ipAddresses"`
	IsCaCertificate *bool    `pulumi:"isCaCertificate"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool                   `pulumi:"setSubjectKeyId"`
	Subject         *tls.CertRequestSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for the GetAdminCertificate method of the RootCa resource.
type RootCaGetAdminCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   pulumi.StringPtrInput
	AllowedUses pulumi.StringArrayInput
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve pulumi.StringPtrInput
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     pulumi.StringArrayInput
	IsCaCertificate pulumi.BoolPtrInput
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput
	Subject         tls.CertRequestSubjectPtrInput
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput
}

func (RootCaGetAdminCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaGetAdminCertificateArgs)(nil)).Elem()
}

type RootCaGetAdminCertificateResult struct {
	Cert *Certificate `pulumi:"cert"`
}

type RootCaGetAdminCertificateResultOutput struct{ *pulumi.OutputState }

func (RootCaGetAdminCertificateResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RootCaGetAdminCertificateResult)(nil)).Elem()
}

func (o RootCaGetAdminCertificateResultOutput) Cert() CertificateOutput {
	return o.ApplyT(func(v RootCaGetAdminCertificateResult) *Certificate { return v.Cert }).(CertificateOutput)
}

// Creates a Certificate configured for the api-server.
func (r *RootCa) GetApiServerCertificate(ctx *pulumi.Context, args *RootCaGetApiServerCertificateArgs) (RootCaGetApiServerCertificateResultOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:index:RootCa/getApiServerCertificate", args, RootCaGetApiServerCertificateResultOutput{}, r)
	if err != nil {
		return RootCaGetApiServerCertificateResultOutput{}, err
	}
	return out.(RootCaGetApiServerCertificateResultOutput), nil
}

type rootCaGetApiServerCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   *string  `pulumi:"algorithm"`
	AllowedUses []string `pulumi:"allowedUses"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *string `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     []string `pulumi:"ipAddresses"`
	IsCaCertificate *bool    `pulumi:"isCaCertificate"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool                   `pulumi:"setSubjectKeyId"`
	Subject         *tls.CertRequestSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for the GetApiServerCertificate method of the RootCa resource.
type RootCaGetApiServerCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   pulumi.StringPtrInput
	AllowedUses pulumi.StringArrayInput
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve pulumi.StringPtrInput
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     pulumi.StringArrayInput
	IsCaCertificate pulumi.BoolPtrInput
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput
	Subject         tls.CertRequestSubjectPtrInput
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput
}

func (RootCaGetApiServerCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaGetApiServerCertificateArgs)(nil)).Elem()
}

type RootCaGetApiServerCertificateResult struct {
	Cert *Certificate `pulumi:"cert"`
}

type RootCaGetApiServerCertificateResultOutput struct{ *pulumi.OutputState }

func (RootCaGetApiServerCertificateResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RootCaGetApiServerCertificateResult)(nil)).Elem()
}

func (o RootCaGetApiServerCertificateResultOutput) Cert() CertificateOutput {
	return o.ApplyT(func(v RootCaGetApiServerCertificateResult) *Certificate { return v.Cert }).(CertificateOutput)
}

// Creates a Certificate configured for the controller manager.
func (r *RootCa) GetControllerManagerCertificate(ctx *pulumi.Context, args *RootCaGetControllerManagerCertificateArgs) (RootCaGetControllerManagerCertificateResultOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:index:RootCa/getControllerManagerCertificate", args, RootCaGetControllerManagerCertificateResultOutput{}, r)
	if err != nil {
		return RootCaGetControllerManagerCertificateResultOutput{}, err
	}
	return out.(RootCaGetControllerManagerCertificateResultOutput), nil
}

type rootCaGetControllerManagerCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   *string  `pulumi:"algorithm"`
	AllowedUses []string `pulumi:"allowedUses"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *string `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     []string `pulumi:"ipAddresses"`
	IsCaCertificate *bool    `pulumi:"isCaCertificate"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool                   `pulumi:"setSubjectKeyId"`
	Subject         *tls.CertRequestSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for the GetControllerManagerCertificate method of the RootCa resource.
type RootCaGetControllerManagerCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   pulumi.StringPtrInput
	AllowedUses pulumi.StringArrayInput
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve pulumi.StringPtrInput
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     pulumi.StringArrayInput
	IsCaCertificate pulumi.BoolPtrInput
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput
	Subject         tls.CertRequestSubjectPtrInput
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput
}

func (RootCaGetControllerManagerCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaGetControllerManagerCertificateArgs)(nil)).Elem()
}

type RootCaGetControllerManagerCertificateResult struct {
	Cert *Certificate `pulumi:"cert"`
}

type RootCaGetControllerManagerCertificateResultOutput struct{ *pulumi.OutputState }

func (RootCaGetControllerManagerCertificateResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RootCaGetControllerManagerCertificateResult)(nil)).Elem()
}

func (o RootCaGetControllerManagerCertificateResultOutput) Cert() CertificateOutput {
	return o.ApplyT(func(v RootCaGetControllerManagerCertificateResult) *Certificate { return v.Cert }).(CertificateOutput)
}

// Creates a Certificate configured for the kube-proxy.
func (r *RootCa) GetKubeProxyCertificate(ctx *pulumi.Context, args *RootCaGetKubeProxyCertificateArgs) (RootCaGetKubeProxyCertificateResultOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:index:RootCa/getKubeProxyCertificate", args, RootCaGetKubeProxyCertificateResultOutput{}, r)
	if err != nil {
		return RootCaGetKubeProxyCertificateResultOutput{}, err
	}
	return out.(RootCaGetKubeProxyCertificateResultOutput), nil
}

type rootCaGetKubeProxyCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   *string  `pulumi:"algorithm"`
	AllowedUses []string `pulumi:"allowedUses"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *string `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     []string `pulumi:"ipAddresses"`
	IsCaCertificate *bool    `pulumi:"isCaCertificate"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool                   `pulumi:"setSubjectKeyId"`
	Subject         *tls.CertRequestSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for the GetKubeProxyCertificate method of the RootCa resource.
type RootCaGetKubeProxyCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   pulumi.StringPtrInput
	AllowedUses pulumi.StringArrayInput
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve pulumi.StringPtrInput
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     pulumi.StringArrayInput
	IsCaCertificate pulumi.BoolPtrInput
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput
	Subject         tls.CertRequestSubjectPtrInput
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput
}

func (RootCaGetKubeProxyCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaGetKubeProxyCertificateArgs)(nil)).Elem()
}

type RootCaGetKubeProxyCertificateResult struct {
	Cert *Certificate `pulumi:"cert"`
}

type RootCaGetKubeProxyCertificateResultOutput struct{ *pulumi.OutputState }

func (RootCaGetKubeProxyCertificateResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RootCaGetKubeProxyCertificateResult)(nil)).Elem()
}

func (o RootCaGetKubeProxyCertificateResultOutput) Cert() CertificateOutput {
	return o.ApplyT(func(v RootCaGetKubeProxyCertificateResult) *Certificate { return v.Cert }).(CertificateOutput)
}

// Creates a Certificate configured for the kube-scheduler.
func (r *RootCa) GetKubeSchedulerCertificate(ctx *pulumi.Context, args *RootCaGetKubeSchedulerCertificateArgs) (RootCaGetKubeSchedulerCertificateResultOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:index:RootCa/getKubeSchedulerCertificate", args, RootCaGetKubeSchedulerCertificateResultOutput{}, r)
	if err != nil {
		return RootCaGetKubeSchedulerCertificateResultOutput{}, err
	}
	return out.(RootCaGetKubeSchedulerCertificateResultOutput), nil
}

type rootCaGetKubeSchedulerCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   *string  `pulumi:"algorithm"`
	AllowedUses []string `pulumi:"allowedUses"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *string `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     []string `pulumi:"ipAddresses"`
	IsCaCertificate *bool    `pulumi:"isCaCertificate"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool                   `pulumi:"setSubjectKeyId"`
	Subject         *tls.CertRequestSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for the GetKubeSchedulerCertificate method of the RootCa resource.
type RootCaGetKubeSchedulerCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   pulumi.StringPtrInput
	AllowedUses pulumi.StringArrayInput
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve pulumi.StringPtrInput
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     pulumi.StringArrayInput
	IsCaCertificate pulumi.BoolPtrInput
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput
	Subject         tls.CertRequestSubjectPtrInput
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput
}

func (RootCaGetKubeSchedulerCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaGetKubeSchedulerCertificateArgs)(nil)).Elem()
}

type RootCaGetKubeSchedulerCertificateResult struct {
	Cert *Certificate `pulumi:"cert"`
}

type RootCaGetKubeSchedulerCertificateResultOutput struct{ *pulumi.OutputState }

func (RootCaGetKubeSchedulerCertificateResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RootCaGetKubeSchedulerCertificateResult)(nil)).Elem()
}

func (o RootCaGetKubeSchedulerCertificateResultOutput) Cert() CertificateOutput {
	return o.ApplyT(func(v RootCaGetKubeSchedulerCertificateResult) *Certificate { return v.Cert }).(CertificateOutput)
}

// Creates a Certificate configured for a kubelet.
func (r *RootCa) GetKubeletCertificate(ctx *pulumi.Context, args *RootCaGetKubeletCertificateArgs) (RootCaGetKubeletCertificateResultOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:index:RootCa/getKubeletCertificate", args, RootCaGetKubeletCertificateResultOutput{}, r)
	if err != nil {
		return RootCaGetKubeletCertificateResultOutput{}, err
	}
	return out.(RootCaGetKubeletCertificateResultOutput), nil
}

type rootCaGetKubeletCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   *string  `pulumi:"algorithm"`
	AllowedUses []string `pulumi:"allowedUses"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *string `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     []string `pulumi:"ipAddresses"`
	IsCaCertificate *bool    `pulumi:"isCaCertificate"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool                   `pulumi:"setSubjectKeyId"`
	Subject         *tls.CertRequestSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for the GetKubeletCertificate method of the RootCa resource.
type RootCaGetKubeletCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   pulumi.StringPtrInput
	AllowedUses pulumi.StringArrayInput
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve pulumi.StringPtrInput
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     pulumi.StringArrayInput
	IsCaCertificate pulumi.BoolPtrInput
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput
	Subject         tls.CertRequestSubjectPtrInput
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput
}

func (RootCaGetKubeletCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaGetKubeletCertificateArgs)(nil)).Elem()
}

type RootCaGetKubeletCertificateResult struct {
	Cert *Certificate `pulumi:"cert"`
}

type RootCaGetKubeletCertificateResultOutput struct{ *pulumi.OutputState }

func (RootCaGetKubeletCertificateResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RootCaGetKubeletCertificateResult)(nil)).Elem()
}

func (o RootCaGetKubeletCertificateResultOutput) Cert() CertificateOutput {
	return o.ApplyT(func(v RootCaGetKubeletCertificateResult) *Certificate { return v.Cert }).(CertificateOutput)
}

// Creates a Certificate configured for the kube-scheduler.
func (r *RootCa) GetServiceAccountsCertificate(ctx *pulumi.Context, args *RootCaGetServiceAccountsCertificateArgs) (RootCaGetServiceAccountsCertificateResultOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:index:RootCa/getServiceAccountsCertificate", args, RootCaGetServiceAccountsCertificateResultOutput{}, r)
	if err != nil {
		return RootCaGetServiceAccountsCertificateResultOutput{}, err
	}
	return out.(RootCaGetServiceAccountsCertificateResultOutput), nil
}

type rootCaGetServiceAccountsCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   *string  `pulumi:"algorithm"`
	AllowedUses []string `pulumi:"allowedUses"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *string `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     []string `pulumi:"ipAddresses"`
	IsCaCertificate *bool    `pulumi:"isCaCertificate"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool                   `pulumi:"setSubjectKeyId"`
	Subject         *tls.CertRequestSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

// The set of arguments for the GetServiceAccountsCertificate method of the RootCa resource.
type RootCaGetServiceAccountsCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   pulumi.StringPtrInput
	AllowedUses pulumi.StringArrayInput
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve pulumi.StringPtrInput
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     pulumi.StringArrayInput
	IsCaCertificate pulumi.BoolPtrInput
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput
	Subject         tls.CertRequestSubjectPtrInput
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput
}

func (RootCaGetServiceAccountsCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaGetServiceAccountsCertificateArgs)(nil)).Elem()
}

type RootCaGetServiceAccountsCertificateResult struct {
	Cert *Certificate `pulumi:"cert"`
}

type RootCaGetServiceAccountsCertificateResultOutput struct{ *pulumi.OutputState }

func (RootCaGetServiceAccountsCertificateResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RootCaGetServiceAccountsCertificateResult)(nil)).Elem()
}

func (o RootCaGetServiceAccountsCertificateResultOutput) Cert() CertificateOutput {
	return o.ApplyT(func(v RootCaGetServiceAccountsCertificateResult) *Certificate { return v.Cert }).(CertificateOutput)
}

// Creates a RemoteFile resource representing the copy operation.
func (r *RootCa) InstallOn(ctx *pulumi.Context, args *RootCaInstallOnArgs) (RootCaInstallOnResultOutput, error) {
	out, err := ctx.Call("kubernetes-the-hard-way:index:RootCa/installOn", args, RootCaInstallOnResultOutput{}, r)
	if err != nil {
		return RootCaInstallOnResultOutput{}, err
	}
	return out.(RootCaInstallOnResultOutput), nil
}

type rootCaInstallOnArgs struct {
	// The connection details.
	Connection remote.Connection `pulumi:"connection"`
	// The path to install to.
	Path *string `pulumi:"path"`
}

// The set of arguments for the InstallOn method of the RootCa resource.
type RootCaInstallOnArgs struct {
	// The connection details.
	Connection remote.ConnectionInput
	// The path to install to.
	Path pulumi.StringPtrInput
}

func (RootCaInstallOnArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rootCaInstallOnArgs)(nil)).Elem()
}

type RootCaInstallOnResult struct {
	File *RemoteFile `pulumi:"file"`
}

type RootCaInstallOnResultOutput struct{ *pulumi.OutputState }

func (RootCaInstallOnResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RootCaInstallOnResult)(nil)).Elem()
}

func (o RootCaInstallOnResultOutput) File() RemoteFileOutput {
	return o.ApplyT(func(v RootCaInstallOnResult) *RemoteFile { return v.File }).(RemoteFileOutput)
}

type RootCaInput interface {
	pulumi.Input

	ToRootCaOutput() RootCaOutput
	ToRootCaOutputWithContext(ctx context.Context) RootCaOutput
}

func (*RootCa) ElementType() reflect.Type {
	return reflect.TypeOf((**RootCa)(nil)).Elem()
}

func (i *RootCa) ToRootCaOutput() RootCaOutput {
	return i.ToRootCaOutputWithContext(context.Background())
}

func (i *RootCa) ToRootCaOutputWithContext(ctx context.Context) RootCaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RootCaOutput)
}

// RootCaArrayInput is an input type that accepts RootCaArray and RootCaArrayOutput values.
// You can construct a concrete instance of `RootCaArrayInput` via:
//
//	RootCaArray{ RootCaArgs{...} }
type RootCaArrayInput interface {
	pulumi.Input

	ToRootCaArrayOutput() RootCaArrayOutput
	ToRootCaArrayOutputWithContext(context.Context) RootCaArrayOutput
}

type RootCaArray []RootCaInput

func (RootCaArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RootCa)(nil)).Elem()
}

func (i RootCaArray) ToRootCaArrayOutput() RootCaArrayOutput {
	return i.ToRootCaArrayOutputWithContext(context.Background())
}

func (i RootCaArray) ToRootCaArrayOutputWithContext(ctx context.Context) RootCaArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RootCaArrayOutput)
}

// RootCaMapInput is an input type that accepts RootCaMap and RootCaMapOutput values.
// You can construct a concrete instance of `RootCaMapInput` via:
//
//	RootCaMap{ "key": RootCaArgs{...} }
type RootCaMapInput interface {
	pulumi.Input

	ToRootCaMapOutput() RootCaMapOutput
	ToRootCaMapOutputWithContext(context.Context) RootCaMapOutput
}

type RootCaMap map[string]RootCaInput

func (RootCaMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RootCa)(nil)).Elem()
}

func (i RootCaMap) ToRootCaMapOutput() RootCaMapOutput {
	return i.ToRootCaMapOutputWithContext(context.Background())
}

func (i RootCaMap) ToRootCaMapOutputWithContext(ctx context.Context) RootCaMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RootCaMapOutput)
}

type RootCaOutput struct{ *pulumi.OutputState }

func (RootCaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RootCa)(nil)).Elem()
}

func (o RootCaOutput) ToRootCaOutput() RootCaOutput {
	return o
}

func (o RootCaOutput) ToRootCaOutputWithContext(ctx context.Context) RootCaOutput {
	return o
}

func (o RootCaOutput) Cert() tls.SelfSignedCertOutput {
	return o.ApplyT(func(v *RootCa) tls.SelfSignedCertOutput { return v.Cert }).(tls.SelfSignedCertOutput)
}

func (o RootCaOutput) CertPem() pulumi.StringOutput {
	return o.ApplyT(func(v *RootCa) pulumi.StringOutput { return v.CertPem }).(pulumi.StringOutput)
}

func (o RootCaOutput) Key() tls.PrivateKeyOutput {
	return o.ApplyT(func(v *RootCa) tls.PrivateKeyOutput { return v.Key }).(tls.PrivateKeyOutput)
}

func (o RootCaOutput) KeyPem() pulumi.StringOutput {
	return o.ApplyT(func(v *RootCa) pulumi.StringOutput { return v.KeyPem }).(pulumi.StringOutput)
}

type RootCaArrayOutput struct{ *pulumi.OutputState }

func (RootCaArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RootCa)(nil)).Elem()
}

func (o RootCaArrayOutput) ToRootCaArrayOutput() RootCaArrayOutput {
	return o
}

func (o RootCaArrayOutput) ToRootCaArrayOutputWithContext(ctx context.Context) RootCaArrayOutput {
	return o
}

func (o RootCaArrayOutput) Index(i pulumi.IntInput) RootCaOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RootCa {
		return vs[0].([]*RootCa)[vs[1].(int)]
	}).(RootCaOutput)
}

type RootCaMapOutput struct{ *pulumi.OutputState }

func (RootCaMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RootCa)(nil)).Elem()
}

func (o RootCaMapOutput) ToRootCaMapOutput() RootCaMapOutput {
	return o
}

func (o RootCaMapOutput) ToRootCaMapOutputWithContext(ctx context.Context) RootCaMapOutput {
	return o
}

func (o RootCaMapOutput) MapIndex(k pulumi.StringInput) RootCaOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RootCa {
		return vs[0].(map[string]*RootCa)[vs[1].(string)]
	}).(RootCaOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RootCaInput)(nil)).Elem(), &RootCa{})
	pulumi.RegisterInputType(reflect.TypeOf((*RootCaArrayInput)(nil)).Elem(), RootCaArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RootCaMapInput)(nil)).Elem(), RootCaMap{})
	pulumi.RegisterOutputType(RootCaOutput{})
	pulumi.RegisterOutputType(RootCaGetAdminCertificateResultOutput{})
	pulumi.RegisterOutputType(RootCaGetApiServerCertificateResultOutput{})
	pulumi.RegisterOutputType(RootCaGetControllerManagerCertificateResultOutput{})
	pulumi.RegisterOutputType(RootCaGetKubeProxyCertificateResultOutput{})
	pulumi.RegisterOutputType(RootCaGetKubeSchedulerCertificateResultOutput{})
	pulumi.RegisterOutputType(RootCaGetKubeletCertificateResultOutput{})
	pulumi.RegisterOutputType(RootCaGetServiceAccountsCertificateResultOutput{})
	pulumi.RegisterOutputType(RootCaInstallOnResultOutput{})
	pulumi.RegisterOutputType(RootCaArrayOutput{})
	pulumi.RegisterOutputType(RootCaMapOutput{})
}
