// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kubernetesthehardway

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/unstoppablemango/pulumi-kubernetes-the-hard-way/sdk/go/kubernetes-the-hard-way/internal"
	"github.com/unstoppablemango/pulumi-kubernetes-the-hard-way/sdk/go/kubernetes-the-hard-way/tls"
)

// Creates a Certificate configured for the current authority.
func NewCertificate(ctx *pulumi.Context, args *NewCertificateArgs, opts ...pulumi.InvokeOption) (*NewCertificateResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv NewCertificateResult
	err := ctx.Invoke("kubernetes-the-hard-way:index:newCertificate", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

type NewCertificateArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   tls.Algorithm      `pulumi:"algorithm"`
	AllowedUses []tls.AllowedUsage `pulumi:"allowedUses"`
	// The certificate authority to issue the certificate.
	Ca *tls.RootCa `pulumi:"ca"`
	// List of DNS names for which a certificate is being requested.
	DnsNames []string `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours *int `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve *tls.EcdsaCurve `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     []string         `pulumi:"ipAddresses"`
	IsCaCertificate *bool            `pulumi:"isCaCertificate"`
	Name            string           `pulumi:"name"`
	Options         *ResourceOptions `pulumi:"options"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits *int `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId *bool `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId *bool               `pulumi:"setSubjectKeyId"`
	Subject         *CertRequestSubject `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris []string `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours int `pulumi:"validityPeriodHours"`
}

type NewCertificateResult struct {
	Result *tls.Certificate `pulumi:"result"`
}

func NewCertificateOutput(ctx *pulumi.Context, args NewCertificateOutputArgs, opts ...pulumi.InvokeOption) NewCertificateResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (NewCertificateResult, error) {
			args := v.(NewCertificateArgs)
			r, err := NewCertificate(ctx, &args, opts...)
			var s NewCertificateResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(NewCertificateResultOutput)
}

type NewCertificateOutputArgs struct {
	// Name of the algorithm to use when generating the private key.
	Algorithm   tls.AlgorithmInput         `pulumi:"algorithm"`
	AllowedUses tls.AllowedUsageArrayInput `pulumi:"allowedUses"`
	// The certificate authority to issue the certificate.
	Ca tls.RootCaInput `pulumi:"ca"`
	// List of DNS names for which a certificate is being requested.
	DnsNames pulumi.StringArrayInput `pulumi:"dnsNames"`
	// TODO
	EarlyRenewalHours pulumi.IntPtrInput `pulumi:"earlyRenewalHours"`
	// When `algorithm` is `ECDSA`, the name of the elliptic curve to use.
	EcdsaCurve tls.EcdsaCurvePtrInput `pulumi:"ecdsaCurve"`
	// List of IP addresses for which a certificate is being requested.
	IpAddresses     pulumi.StringArrayInput `pulumi:"ipAddresses"`
	IsCaCertificate pulumi.BoolPtrInput     `pulumi:"isCaCertificate"`
	Name            string                  `pulumi:"name"`
	Options         *ResourceOptionsArgs    `pulumi:"options"`
	// When `algorithm` is `RSA`, the size of the generated RSA key, in bits.
	RsaBits pulumi.IntPtrInput `pulumi:"rsaBits"`
	// Should the generated certificate include an authority key identifier.
	SetAuthorityKeyId pulumi.BoolPtrInput `pulumi:"setAuthorityKeyId"`
	// Should the generated certificate include a subject key identifier.
	SetSubjectKeyId pulumi.BoolPtrInput        `pulumi:"setSubjectKeyId"`
	Subject         CertRequestSubjectPtrInput `pulumi:"subject"`
	// List of URIs for which a certificate is being requested.
	Uris pulumi.StringArrayInput `pulumi:"uris"`
	// Number of hours, after initial issuing, that the certificate will remain valid.
	ValidityPeriodHours pulumi.IntInput `pulumi:"validityPeriodHours"`
}

func (NewCertificateOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NewCertificateArgs)(nil)).Elem()
}

type NewCertificateResultOutput struct{ *pulumi.OutputState }

func (NewCertificateResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NewCertificateResult)(nil)).Elem()
}

func (o NewCertificateResultOutput) ToNewCertificateResultOutput() NewCertificateResultOutput {
	return o
}

func (o NewCertificateResultOutput) ToNewCertificateResultOutputWithContext(ctx context.Context) NewCertificateResultOutput {
	return o
}

func (o NewCertificateResultOutput) Result() tls.CertificateOutput {
	return o.ApplyT(func(v NewCertificateResult) *tls.Certificate { return v.Result }).(tls.CertificateOutput)
}

func init() {
	pulumi.RegisterOutputType(NewCertificateResultOutput{})
}
